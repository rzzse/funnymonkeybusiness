<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="referrer" content="no-referrer">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>opentheatre</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/simple-keyboard@latest/build/css/index.css">
    <link href="https://fonts.googleapis.com/css2?family=Consolas:wght@400;700&family=Cousine&family=Electrolize&family=Fira+Sans:wght@400;700&family=Inter:wght@400;700&family=Lato:wght@400;700&family=Merriweather:wght@400;700&family=Monoton&family=Open+Sans:wght@400;700&family=Roboto+Mono:wght@400;700&family=Space+Mono:wght@400;700&family=VT323&display=swap" rel="stylesheet">
    <style>
        @keyframes fadeIn { to { opacity: 0.8; } }

        /* ==============================================================================================
           THEME DEFINITIONS
        ============================================================================================== */
        :root, .theme-console { --font-primary: 'Consolas', monospace; --bg: #000000; --card-bg: #111111; --text: #ffffff; --text-secondary: #aaaaaa; --accent: #ffffff; --border: #333333; --progress: #e50914; --glow: 0 0 20px rgba(255, 255, 255, 0.5); --input-bg: #0a0a0a; --overlay-darkness: 0.7; --modal-backdrop-color: rgba(0, 0, 0, 0.85); --keyboard-bg: #111; --keyboard-key-bg: #222; --keyboard-key-text: #fff; }
        .theme-matrix-green { --font-primary: 'VT323', monospace; --bg: #000000; --card-bg: #031503; --text: #00ff41; --text-secondary: #00aa22; --accent: #00ff41; --border: #004400; --progress: #00ff41; --glow: 0 0 15px rgba(0, 255, 65, 0.7); --input-bg: #000000; --overlay-darkness: 0.8; --modal-backdrop-color: rgba(0, 0, 0, 0.9); --keyboard-bg: #031503; --keyboard-key-bg: #002200; --keyboard-key-text: #00ff41; }
        .theme-oled-black { --font-primary: 'Roboto Mono', monospace; --bg: #000000; --card-bg: #050505; --text: #ffffff; --text-secondary: #666666; --accent: #ffffff; --border: #333333; --progress: #00FFFF; --glow: 0 0 12px rgba(0, 255, 255, 0.5); --input-bg: #000000; --overlay-darkness: 0.9; --modal-backdrop-color: rgba(0, 0, 0, 0.95); --keyboard-bg: #000; --keyboard-key-bg: #111; --keyboard-key-text: #fff; }
        .theme-light-mode { --font-primary: 'Open Sans', sans-serif; --bg: #f0f0f0; --card-bg: #ffffff; --text: #111111; --text-secondary: #555555; --accent: #007bff; --border: #cccccc; --progress: #007bff; --glow: 0 0 10px rgba(0, 123, 255, 0.5); --input-bg: #e5e5e5; --overlay-darkness: 0.3; --modal-backdrop-color: rgba(255, 255, 255, 0.85); }
        .theme-tokyo-night { --font-primary: 'Inter', sans-serif; --bg: #1a1b26; --card-bg: #24283b; --text: #a9b1d6; --text-secondary: #707e99; --accent: #bb9af7; --border: #414868; --progress: #ff7a93; --glow: 0 0 15px #bb9af7; --input-bg: #161821; --overlay-darkness: 0.7; --modal-backdrop-color: rgba(26, 27, 38, 0.9); }
        .theme-cyberpunk-neon { --font-primary: 'Electrolize', sans-serif; --bg: #000000; --card-bg: #1A0030; --text: #00FFFF; --text-secondary: #FF00FF; --accent: #00FFFF; --border: #330066; --progress: #FF00FF; --glow: 0 0 20px rgba(255, 0, 255, 1); --input-bg: #050010; --overlay-darkness: 0.85; --modal-backdrop-color: rgba(0, 0, 0, 0.95); }
        .theme-vaporwave { --font-primary: 'Monoton', cursive; --bg: #000022; --card-bg: #111144; --text: #FF69B4; --text-secondary: #66CCFF; --accent: #FF69B4; --border: #330099; --progress: #66CCFF; --glow: 0 0 25px #FF69B4; --input-bg: #000011; --overlay-darkness: 0.6; --modal-backdrop-color: rgba(0, 0, 34, 0.8); }
        .theme-sunset { --font-primary: 'Lato', sans-serif; --bg: #1a1a1a; --card-bg: #333333; --text: #FFA500; --text-secondary: #EEEEEE; --accent: #FF4500; --border: #888888; --progress: #FF4500; --glow: 0 0 15px #FFA500; --input-bg: #222222; --overlay-darkness: 0.5; --modal-backdrop-color: rgba(26, 26, 26, 0.8); }
        .theme-deep-blue { --font-primary: 'Space Mono', monospace; --bg: #02021a; --card-bg: #05052a; --text: #66CCFF; --text-secondary: #AAAAFF; --accent: #FFFFFF; --border: #004488; --progress: #66CCFF; --glow: 0 0 12px #66CCFF; --input-bg: #01010d; --overlay-darkness: 0.7; --modal-backdrop-color: rgba(2, 2, 26, 0.9); }
        .theme-monochrome { --font-primary: 'Cousine', monospace; --bg: #111111; --card-bg: #222222; --text: #FFFFFF; --text-secondary: #999999; --accent: #FFFFFF; --border: #666666; --progress: #FFFFFF; --glow: 0 0 10px #999999; --input-bg: #000000; --overlay-darkness: 0.8; --modal-backdrop-color: rgba(17, 17, 17, 0.9); }
        .theme-dark-mint { --font-primary: 'Fira Sans', sans-serif; --bg: #111a1a; --card-bg: #1a2a2a; --text: #66FFD9; --text-secondary: #AAAAAA; --accent: #FFFFFF; --border: #333333; --progress: #66FFD9; --glow: 0 0 15px #66FFD9; --input-bg: #0a1010; --overlay-darkness: 0.7; --modal-backdrop-color: rgba(17, 26, 26, 0.9); }
        .theme-golden-ember { --font-primary: 'Merriweather', serif; --bg: #1a150a; --card-bg: #2a2010; --text: #FFD700; --text-secondary: #EEDD82; --accent: #FF8C00; --border: #4A4030; --progress: #FF8C00; --glow: 0 0 18px #FFD700; --input-bg: #100d05; --overlay-darkness: 0.65; --modal-backdrop-color: rgba(26, 21, 10, 0.85); }

        /* --- CORE LAYOUT --- */
        html, body {
    scrollbar-width: none;  /* Firefox */
    -ms-overflow-style: none;  /* IE/Edge */
}
html::-webkit-scrollbar, body::-webkit-scrollbar {
    display: none; /* Chrome/Safari */
}
body { font-family: var(--font-primary, 'Consolas', monospace); background: var(--bg); color: var(--text); letter-spacing: 1px; overflow-x: hidden; }
        .main-content { flex-grow: 1; transition: filter 0.5s ease-in-out; display: flex; flex-direction: column; }

        body.viewing-mode header {
    display: none !important;
}


/* --- RESTORING THE CLEAN CINEMATIC LOOK --- */

/* 1. Kill the Header and Footer instantly in viewing mode */
body.viewing-mode {
    background: #000 !important;
    margin: 0 !important;
    overflow-x: hidden !important;
    overflow-y: auto !important;   /* Enable vertical scrolling */
}

body.viewing-mode header, 
body.viewing-mode footer {
    display: none !important;
}

/* FIX: Reset parent containers so the player isn't squished */
body.viewing-mode .main-content {
    margin: 0 !important;
    padding: 0 !important;
    width: 100% !important;
}

body.viewing-mode #detail {
    display: block !important;
    width: 100vw !important;
    max-width: none !important;
    margin: 0 !important;
    padding: 0 !important;
}

/* THE PLAYER CONTAINER */
body.viewing-mode .player-container {
    position: relative !important;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 9999 !important;
    background: #000 !important;
    border: none !important;
    margin: 0 !important;
    padding: 0 !important;
    border-radius: 0 !important; /* Sharp Corners */
    box-shadow: none !important;
    overflow: hidden;
}

/* THE OVERSCAN FIX (-2px as requested) */
body.viewing-mode .player {
    position: absolute !important;
    top: -2px !important;
    left: -2px !important;
    width: calc(100% + 4px) !important;
    height: calc(100% + 4px) !important;
    border: none !important;
    background: #000 !important;
    border-radius: 0 !important; /* Sharp Corners */
}

/* Ensure controls below are visible */
body.viewing-mode .detail-info-tile,
body.viewing-mode .tv-controls-container {
    display: flex !important;
    position: relative;
    z-index: 5;
    background: #000;
    margin-top: 0;
    border-top: 1px solid #222;
}

body.viewing-mode #customHUD {
    z-index: 100000 !important;
}

        /* --- ANIMATIONS & FOCUS --- */
        @keyframes shakeRamp {
            0%   { transform: scale(1.0); }
            20%  { transform: scale(1.02) rotate(1deg); }
            40%  { transform: scale(1.04) rotate(-1deg); }
            60%  { transform: scale(1.06) rotate(1deg); }
            80%  { transform: scale(1.08) rotate(-1deg); }
            100% { transform: scale(1.1)  rotate(0deg); }
        }
        
        .carousel-item.shaking, .grid-item.shaking {
            animation: shakeRamp 1s ease-in forwards !important;
            border-color: var(--progress) !important;
            box-shadow: 0 0 20px rgba(229, 9, 20, 0.6) !important;
        }

        * { 
    cursor: none !important; /* Global system cursor hide */
}

/* Force hide cursor on tricky elements (Embeds, Inputs, Links) */
iframe, select, input, textarea, button, a { 
    cursor: none !important; 
}

.cursor-dot, .cursor-trail {
    position: fixed;
    top: 0; 
    left: 0;
    border-radius: 50%;
    pointer-events: none; /* Allows clicks to pass through to videos/buttons */
    z-index: 2147483647; /* MAX Z-INDEX: Stays on top of EVERYTHING */
}

/* The Main Ball */
.cursor-dot {
    width: 12px; 
    height: 12px;
    background: var(--accent); /* Theme Aware */
    box-shadow: 0 0 10px var(--accent), 0 0 20px var(--accent);
    
    /* Fade Logic */
    opacity: 0; /* Hidden by default */
    transition: opacity 0.1s ease-out; /* Fast fade out */
}

/* --- CUSTOM HUD --- */
/* --- CENTERED HORIZONTAL HUD --- */
/* --- CUSTOM HUD - Reconstructed Console Style --- */

.floating-back-btn {
    position: absolute; /* Changed from fixed */
    top: 40px;
    left: 40px;
    background: rgba(0, 0, 0, 0.5);
    color: rgba(255, 255, 255, 0.7);
    border: 2px solid transparent;
    font-family: var(--font-primary);
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
    padding: 10px 25px;
    border-radius: 8px;
    z-index: 100001;
    
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
    backdrop-filter: blur(5px);
}

.floating-back-btn.visible {
    opacity: 1;
    pointer-events: auto;
}

.floating-back-btn.nav-focus {
    color: var(--accent);
    border-color: var(--accent);
    background: rgba(0, 0, 0, 0.9);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--glow);
}

#customHUD {
    position: absolute; /* Changed from fixed */
    bottom: 75px;       /* Pinned to bottom of VIDEO, not screen */
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    max-width: 1200px;
    height: 140px;
    background: var(--card-bg);
    border: 1px solid var(--border);
    border-radius: 20px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.7), inset 0 1px 8px rgba(255,255,255,0.08);
    z-index: 100000;    /* Above video, below global modals */
    display: none;
    flex-direction: column;
    padding: 16px 40px 12px 40px;
    box-sizing: border-box;
    backdrop-filter: blur(10px);
    
    /* FADE LOGIC */
    opacity: 0;
    transition: opacity 0.5s ease;
    pointer-events: none;
}

/* When visible class is added by JS */
#customHUD.visible,
.floating-back-btn.visible {
    opacity: 1;
    pointer-events: auto;
}

body.video-ready.user-active #customHUD {
    display: flex !important;
    opacity: 1;
    pointer-events: auto;
}

/* Progress Bar - Full width, no margin waste */
.hud-progress-container {
    width: 100%;
    height: 8px;
    background: rgba(255, 255, 255, 0.08);
    cursor: pointer;
    margin: 0 0 16px 0;                  /* Space above buttons only */
    border-radius: 4px;
    overflow: hidden;
    border: 1px solid var(--border);
    pointer-events: auto !important;
}


/* Progress Fill - Theme glow */


/* Controls Row - Tight & Centered */
.hud-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 70px;
    padding: 0;
    margin: 0;
}

/* Buttons - Console style */
.hud-btn {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    
    /* Remove text font sizes, SVGs handle their own size */
    cursor: pointer;
    transition: all 0.2s ease;
    text-shadow: none;
    
    /* Flex to center the SVG inside the button */
    display: flex;
    align-items: center;
    justify-content: center;
}


.hud-btn:hover,
.hud-btn:focus,
.hud-btn.nav-focus {
    color: var(--accent);
    transform: scale(1.15);
    text-shadow: none;
    outline: none;
}
#hudBackBtn, #customHUD { display: none !important; }
body.viewing-mode #hudBackBtn, 
body.viewing-mode #customHUD { display: flex !important; }

body.viewing-mode.user-active .floating-back-btn,
body.viewing-mode.user-active #customHUD {
    opacity: 1;
    pointer-events: auto;
}

/* THE ENFORCER: Force all HUD icons to be identical */
.hud-btn svg {
    width: 60px !important;
    height: 60px !important;
    min-width: 60px !important;
    min-height: 60px !important;
    max-width: 60px !important;
    max-height: 60px !important;
    transform: none !important; /* Prevents independent scaling */
}

/* Reset the Play Button container to behave like the others */
#hudPlayPause {
    width: auto !important;
    height: auto !important;
    border: none !important;
    padding: 0 !important;
    margin: 0 !important;
}

/* Time Display - Monospace & Glow */
#hudTime {
    font-family: var(--font-primary);
    color: var(--accent);
    font-size: 20px;
    font-weight: bold;
    text-shadow: var(--glow none);
    margin-left: 20px;                   /* Slight offset for balance */
    letter-spacing: 1px;
}

/* =========================================================================
   SMART LOADER OVERLAY (Added)
   ========================================================================= */
#smartLoader {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    z-index: 100000;
    background: #000;
    display: none; /* Controlled by .active class */
    pointer-events: none !important; 
}



#smartLoader.active {
    display: flex;
}

#smartLoader img {
    width: 100%;
    height: 100%;
    object-fit: cover; /* Prevents stretching, fills screen perfectly */
    filter: brightness(0.4); /* Darken so spinner/text pops */
}

#loaderBackdrop {
    width: 100%;
    height: 100%;
    object-fit: cover;
    pointer-events: none !important;
}

.loader-content {
    position: absolute;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
}

.loader-spinner {
    width: 80px;
    height: 80px;
    border: 5px solid rgba(255,255,255,0.1);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.hud-progress-bar {
    height: 100%;
    background: var(--progress);
    width: 0%;
    box-shadow: var(--glow);
    transition: width 0.18s linear;
}








/* The Trails */
.cursor-trail {
    width: 12px; 
    height: 12px;
    background: var(--accent); /* Theme Aware */
    filter: blur(2px);
    
    /* Fade Logic */
    opacity: 0 !important; /* Force hidden by default */
    transition: opacity 0.1s ease-out, transform 0s linear; /* Fast fade out */
}

/* --- ACTIVE STATE (When moving) --- */
body.user-active .cursor-dot {
    opacity: 1;
    transition: opacity 0.3s ease-in; /* Slow fade in */
}

body.user-active .cursor-trail {
    opacity: 0.4 !important; /* Trail transparency */
    transition: opacity 0.3s ease-in; /* Slow fade in */
}

/* HOVER PROTECTION: Disable zoom/hover effects when cursor is hidden */
body:not(.user-active) .carousel-item:hover,
body:not(.user-active) .grid-item:hover {
    transform: none !important;
    box-shadow: none !important;
    border-color: transparent !important;
    z-index: 1 !important;
}

/* The Main Ball - Matches Theme Accent */
.cursor-dot {
    width: 12px; height: 12px;
    background: var(--accent); /* DYNAMIC THEME COLOR */
    box-shadow: 0 0 10px var(--accent), 0 0 20px var(--accent);
}

/* The Motion Blur Trails - Matches Theme Accent */
.cursor-trail {
    width: 12px; height: 12px;
    background: var(--accent); /* DYNAMIC THEME COLOR */
    opacity: 0.4; /* Semi-transparent for trail effect */
    filter: blur(2px);
}

        /* Active State (Visible) */
body.user-active .cursor-dot, 
body.user-active .cursor-trail {
    opacity: 1;
}

/* Trail opacity override when active */
body.user-active .cursor-trail {
    opacity: 0.4;
}

/* HOVER PROTECTION: Disable zoom when cursor is inactive */
body:not(.user-active) .carousel-item:hover,
body:not(.user-active) .grid-item:hover {
    transform: none !important;
    box-shadow: none !important;
    border-color: transparent !important;
    z-index: 1 !important;
}

        :focus { outline: none; }
        html, body { scroll-behavior: smooth; } 
        
        /* CARD STYLES */
        .carousel-item, .grid-item { cursor: pointer; border: 2px solid var(--border); transition: all 0.4s; position: relative; outline: none; content-visibility: auto; contain-intrinsic-size: 220px 330px; will-change: transform; }
        
        .carousel-item:focus, .carousel-item:hover, .grid-item:focus, .grid-item:hover { transform: scale(1.15); z-index: 100; box-shadow: var(--glow); border-color: var(--accent); outline: none; transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
        .carousel-item:focus img, .carousel-item:hover img, .grid-item:focus img, .grid-item:hover img { filter: brightness(1.2); }
        .carousel-item:focus .carousel-item-title, .carousel-item:hover .carousel-item-title { position: absolute; bottom: 0; left: 0; right: 0; padding: 40px 10px 10px; background: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,0)); font-size: 14px; text-align: center; opacity: 1; transition: opacity 0.2s; text-shadow: 0 1px 2px black; pointer-events: none; }
        
        .logo-menu-item:focus { background: var(--accent); color: #000; outline: none; }
        .switch input:focus + .slider { box-shadow: 0 0 10px var(--accent); border: 2px solid var(--accent); }
        .close:focus { color: var(--progress); transform: scale(1.2); outline: none; }
        select:focus, .fullscreen-btn:focus, .profile-manage-btn:focus { border-color: var(--accent); box-shadow: 0 0 15px var(--accent); transform: scale(1.05); }
        .tab:focus { color: var(--accent); text-shadow: var(--glow); text-decoration: underline; }
        
        #searchInput { width: 100%; padding: 14px 20px; border: 2px solid var(--accent); background: var(--input-bg); color: var(--text); font-size: 15px; box-shadow: var(--glow); transition: box-shadow 0.3s; font-family: var(--font-primary, 'Consolas', monospace); position: relative; box-sizing: border-box; }
        #searchInput:focus { box-shadow: 0 0 15px var(--accent); border-color: var(--accent); }
        .logo:focus { filter: brightness(1.3); text-shadow: 0 0 10px var(--accent); color: var(--accent); }

        /* --- BOOT SCREEN & PROFILES --- */
        .boot-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.8s cubic-bezier(0.2, 0.8, 0.2, 1), transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1), border-color 0.2s ease; }
        .boot-logo { font-family: 'Consolas', monospace; font-size: 4rem; color: var(--accent); letter-spacing: 5px; text-shadow: 0 0 20px var(--accent); animation: pulseLogo 2s infinite; }
        .boot-loader { width: 50px; height: 4px; background: #333; margin-top: 20px; position: relative; overflow: hidden; }
        .boot-loader::after { content: ''; position: absolute; top: 0; left: 0; height: 100%; width: 50%; background: var(--accent); animation: loadBar 1.5s infinite ease-in-out; }
        .profile-gate { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9998; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.5s, transform 0.5s; opacity: 0; pointer-events: none; }
        .profile-gate.visible { opacity: 1; pointer-events: all; }
        .profile-title { font-size: 3.5rem; margin-bottom: 50px; font-weight: 400; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.2); }
        .profile-container { display: flex; gap: 40px; margin-bottom: 60px; flex-wrap: wrap; justify-content: center; max-width: 1200px; }
        .profile-card { display: flex; flex-direction: column; align-items: center; gap: 15px; cursor: pointer; transition: transform 0.2s; outline: none; position: relative; }
        .profile-card:hover, .profile-card:focus { transform: scale(1.1); }
        .profile-card:hover .profile-avatar, .profile-card:focus .profile-avatar { border-color: #fff; box-shadow: 0 0 20px rgba(255,255,255,0.3); }
        .profile-avatar { width: 150px; height: 150px; border-radius: 8px; background-size: cover; background-position: center; border: 3px solid transparent; transition: all 0.2s; background-color: #222; position: relative; overflow: hidden; }
        .profile-name { font-size: 1.5rem; color: #808080; transition: color 0.2s; }
        .profile-card:hover .profile-name { color: #fff; }
        
        .profile-gate.manage-mode .profile-avatar { opacity: 0.5; }
        .profile-gate.manage-mode .profile-card:hover .profile-avatar { opacity: 1; }
        .profile-edit-icon { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 40px; opacity: 0; transition: opacity 0.2s; pointer-events: none; text-shadow: 0 0 10px #000; }
        .profile-gate.manage-mode .profile-edit-icon { opacity: 1; }
        
        .profile-manage-btn { border: 1px solid #808080; color: #808080; padding: 10px 30px; letter-spacing: 2px; cursor: pointer; transition: all 0.2s; font-size: 1.2rem; background: transparent; }
        .profile-manage-btn:hover, .profile-manage-btn:focus { border-color: #fff; color: #fff; background: rgba(255,255,255,0.1); }

        .edit-profile-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 10000; display: none; justify-content: center; align-items: center; }
        .edit-profile-modal.visible { display: flex; }
        .edit-profile-content { background: #111; padding: 40px; border: 2px solid var(--accent); border-radius: 10px; width: 500px; display: flex; flex-direction: column; gap: 20px; box-shadow: var(--glow); }
        .edit-input { background: #222; border: 1px solid #444; color: #fff; padding: 15px; font-size: 1.2rem; font-family: inherit; }
        .edit-buttons { display: flex; gap: 20px; margin-top: 20px; }
        .btn-primary { background: var(--text); color: #000; padding: 10px 20px; border: none; font-weight: bold; cursor: pointer; flex: 1; text-transform: uppercase; }
        .btn-secondary { background: transparent; color: #fff; padding: 10px 20px; border: 1px solid #fff; cursor: pointer; flex: 1; text-transform: uppercase; }
        .btn-danger { background: transparent; color: #e50914; padding: 10px 20px; border: 1px solid #e50914; cursor: pointer; flex: 1; text-transform: uppercase; }
        .avatar-picker-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; margin-top: 10px; max-height: 300px; overflow-y: auto; padding: 10px; }
        .avatar-option { width: 80px; height: 80px; border-radius: 5px; cursor: pointer; border: 2px solid transparent; background-size: cover; background-position: center; }
        .avatar-option:hover, .avatar-option.selected { border-color: var(--accent); transform: scale(1.1); }

        @keyframes pulseLogo { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        @keyframes loadBar { 0% { left: -50%; } 100% { left: 100%; } }

        /* --- Header --- */
        header { padding: 20px 60px; display: flex; justify-content: space-between; align-items: center; position: sticky; top: 0; background: var(--bg); z-index: 1000; gap: 40px; flex-shrink: 0; }
        .header-left { display: flex; align-items: center; gap: 40px; flex-grow: 1; min-width: 0; max-width: 45%; }
        .logo-wrapper { position: relative; flex-shrink: 0; }
        .logo { margin: 0; font-size: 36px; font-weight: 700; color: var(--accent); cursor: pointer; position: relative; z-index: 101; outline: none;}
        .logo-menu { position: absolute; top: 100%; left: 0; width: 250px; background: var(--bg); border: none; box-shadow: 0 5px 15px rgba(255, 255, 255, 0.1), 0 0 10px rgba(0, 0, 0, 0.8); z-index: 2000; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-in-out; }
        .logo-menu.visible { max-height: 500px; }
        .logo-menu-item { padding: 15px 25px; cursor: pointer; font-size: 18px; transition: background 0.2s; white-space: nowrap; }
        .tabs { display: flex; gap: 40px; }
        .tab { padding: 10px 0; font-weight: 700; cursor: pointer; position: relative; font-size: 20px; transition: all 0.3s; outline: none; }
        .tab.active, .tab:hover { color: var(--accent); text-shadow: none; }
        .search { max-width: 300px; width: 100%; flex-shrink: 0; }
        
        /* --- Hero --- */
        .hero-container { position: relative; margin-bottom: 60px; }
        .hero { height: 40vh; position: relative; overflow: hidden; }
        .hero-bg-layer { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-size: cover; background-position: center; opacity: 0; transition: opacity 1s ease-in-out, transform 10s linear; }
        .hero-bg-layer.active { opacity: 1; animation: imagePanZoom 16s linear forwards; }
        @keyframes imagePanZoom { 0% { transform: scale(1.0) translate(0, 0); } 100% { transform: scale(1.2) translate(-5%, -5%); } }
        .fading-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, var(--overlay-darkness)); z-index: 5; }
        .hero-content { position: absolute; bottom: 60px; left: 60px; color: var(--text); z-index: 10; }
        .hero-title { font-size: 72px; font-weight: 800; margin: 0; text-shadow: var(--glow); }
        .hero-desc { font-size: 26px; max-width: 900px; margin: 40px 0; text-shadow: 0 0 20px #000; min-height: 35px; } 
        .hero-desc.typing { width: 0; overflow: hidden; white-space: nowrap; animation: typing 1.8s steps(90, end) forwards; }
        @keyframes typing { from { width: 0 } to { width: 100% } }
        .hero-desc.typed { animation: none; width: auto; border-right: none; white-space: nowrap; overflow: hidden; }

       /* --- Carousel --- */
        .row { margin-bottom: 50px; position: relative; }
        .row-title { font-size: 28px; margin: 0 0 10px 60px; font-weight: 700; color: var(--accent); z-index: 5; position: relative; }
        .carousel-container { position: relative; width: 100%; }
        .carousel { 
            display: flex; 
            gap: 20px; 
            overflow-x: auto; 
            padding: 50px 60px 60px; 
            margin-top: -40px; 
            scroll-behavior: smooth; 
            scrollbar-width: none; 
            -ms-overflow-style: none; 
            position: relative; 
            z-index: 1; 
            align-items: start; 
        }
        .carousel::-webkit-scrollbar { display: none; }
        
        .carousel-item { 
            flex: 0 0 220px; 
            width: 220px; 
            aspect-ratio: 2/3; 
            background: var(--card-bg); 
            border: 2px solid transparent; 
            cursor: pointer; 
            position: relative; 
            border-radius: 8px; 
            overflow: hidden; 
            content-visibility: auto; 
            contain-intrinsic-size: 220px 330px; 
            
            /* ANIMATION INITIAL STATE */
            opacity: 0;
            transform: translateY(30px) scale(0.95);
            transition: opacity 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), border-color 0.2s ease;
            will-change: transform, opacity;
        }

        .carousel-item.visible { 
            opacity: 1; 
            transform: translateY(0) scale(1); 
        }

        .carousel-item:focus, .carousel-item:hover { 
            transform: scale(1.15) !important;
            z-index: 100; 
            box-shadow: var(--glow); 
            border-color: var(--accent); 
            outline: none; 
            transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94), border-color 0.2s ease; 
        }

        .hud-top-row {
    width: 100%;
    display: flex;
    justify-content: flex-start;
    margin-bottom: 10px;
}

.hud-back-btn {
    background: transparent;
    color: var(--text-secondary);
    border: 1px solid transparent;
    font-family: var(--font-primary);
    font-size: 18px;
    cursor: pointer;
    padding: 5px 15px;
    border-radius: 4px;
    text-transform: lowercase;
    transition: all 0.2s;
}

#updateBtn.update-ready {
    color: var(--accent) !important;
    font-weight: bold;
    text-shadow: 0 0 10px var(--accent);
    animation: pulseUpdate 1.5s infinite;
}
#updateBtn.update-error { color: #e50914 !important; }

@keyframes pulseUpdate {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

/* Focused State for Back Button & Controls */
.hud-back-btn.nav-focus,
.hud-btn.nav-focus,
select.nav-focus {
    color: var(--accent);
    /* text-shadow: 0 0 10px var(--accent); <-- REMOVE THIS LINE */
    text-shadow: none; /* Add this */
    transform: scale(1.1);
    border-color: var(--accent); 
    outline: none;
}
select.editing { 
    box-shadow: 0 0 20px #ffffff !important; 
    border-color: #ffffff !important; 
    color: #ffffff !important;
}

.hud-btn.active-press {
    transform: scale(0.9) !important;
    color: var(--progress) !important;
    text-shadow: 0 0 15px var(--progress) !important;
}

/* PROGRESS BAR FOCUS STATE */
.hud-progress-container.nav-focus {
    box-shadow: 0 0 15px var(--progress);
    border-color: var(--progress);
    transform: scaleY(1.2); /* Make it slightly thicker */
    transition: all 0.2s ease;
}

/* The red dragger handle (hidden unless focused/active) */
.progress-handle {
    position: absolute;
    top: 0; bottom: 0; right: 0; /* logic moves width, this follows */
    width: 4px;
    background: #fff;
    box-shadow: 0 0 10px #fff;
    opacity: 0;
}

.hud-progress-container.nav-focus .progress-handle {
    opacity: 1;
}

        .carousel-item img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .progress-bar { position: absolute; bottom: 0; left: 0; height: 4px; background: var(--progress); width: 0%; z-index: 2; }
        .carousel-item-title { position: absolute; bottom: 0; left: 0; right: 0; padding: 40px 10px 10px; background: linear-gradient(to top, rgba(0,0,0,0.9), transparent); font-size: 14px; text-align: center; opacity: 0; transition: opacity 0.2s; }

        /* --- CONTEXT MENU & DOTS --- */
        .more-options-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 200; 
            font-size: 18px;
            opacity: 0; 
            transition: opacity 0.2s, transform 0.2s;
            border: 1px solid rgba(255,255,255,0.3);
            pointer-events: all;
        }
        
        .carousel-item:hover .more-options-btn,
        .grid-item:hover .more-options-btn,
        .more-options-btn:focus {
            opacity: 1;
        }

        .more-options-btn:hover {
            background: var(--accent);
            color: #000;
            transform: scale(1.1);
        }

        .context-menu {
            position: absolute;
            background: var(--card-bg);
            border: 2px solid var(--accent);
            border-radius: 8px;
            padding: 10px 0;
            width: 200px;
            z-index: 10000;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
        }
        
        .context-menu.visible { display: flex; }

        .context-menu-item {
            padding: 12px 20px;
            cursor: pointer;
            color: var(--text);
            font-size: 16px;
            transition: background 0.2s;
            text-align: left;
        }

        .context-menu-item:hover {
            background: rgba(255,255,255,0.1);
            color: var(--accent);
        }

        .context-menu-item.selected {
            background: var(--accent);
            color: #000;
        }
        
        .context-menu-item.danger { color: #ffffff; }
        .context-menu-item.danger:hover { background: rgba(255, 68, 68, 0.1); }

        /* --- Grid --- */
        .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 30px; padding: 40px; max-width: 1600px; margin: 0 auto; }
        .grid-item { 
            cursor: pointer; 
            border: 2px solid var(--border); 
            transition: all 0.4s; 
            position: relative; 
            opacity: 0; 
            outline: none;
            aspect-ratio: 2/3; 
            overflow: hidden; 
            background: var(--card-bg); 
        }
        .grid-item.visible, .carousel-item.visible { opacity: 1; transform: none; }
        .grid-item img { width: 100%; height: 100%; object-fit: cover; filter: brightness(0.9); display: block; }
        .grid-item-title { position: absolute; bottom: 0; left: 0; right: 0; padding: 30px 10px 10px; background: linear-gradient(to top, rgba(0,0,0,1) 0%, rgba(0,0,0,0.8) 50%, transparent 100%); color: #ffffff; font-size: 15px; font-weight: 700; text-align: center; text-shadow: 0 2px 4px black; opacity: 1; pointer-events: none; z-index: 20; }
        #loadMoreSentinel { height: 1px; width: 100%; margin-top: 50px; } 

        /* --- Detail --- */
        .detail { max-width: 1400px; margin: 0 auto; padding: 40px 20px; opacity: 0; transition: opacity 0.5s ease; }
        .detail.visible { opacity: 1; }
        .detail-info-tile { display: flex; gap: 40px; background: var(--card-bg); border: 2px solid var(--border); padding: 40px; margin-bottom: 40px; box-shadow: var(--glow); align-items: flex-start; }
        .detail-poster-small { width: 300px; border: 2px solid var(--accent); overflow: hidden; box-shadow: var(--glow); flex-shrink: 0; }
        .detail-poster-small img { width: 100%; display: block; aspect-ratio: 2/3; object-fit: cover; } 
        .detail-text { flex-grow: 1; }
        .detail-text h2 { font-size: 48px; margin: 0 0 10px; text-shadow: var(--glow); }
        .metadata { display: flex; gap: 20px; margin-bottom: 20px; font-size: 20px; font-weight: 700; color: var(--accent); }
        .metadata span { border: 1px solid var(--border); padding: 5px 10px; background: var(--input-bg); }
        .detail-overview { font-size: 20px; line-height: 1.8; color: #cccccc; margin-bottom: 30px; }
        .cast-list h3 { font-size: 28px; margin-bottom: 15px; color: var(--text); text-shadow: var(--glow); }
        .cast-item { display: inline-block; background: var(--input-bg); padding: 10px 20px; margin-right: 15px; margin-bottom: 10px; border: 1px solid var(--border); font-size: 18px; }
        .cast-item .character { color: var(--text-secondary); font-size: 16px; display: block; }

        /* --- Player --- */
        .player-container {
    position: relative !important; /* Establishes the coordinate system */
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: #000;
}
.player { width: 100%; height: 70vh; min-height: 560px; border: none; transition: filter 0.5s ease-in-out; }
        .player.quality-enhanced { filter: blur(0.2px) contrast(1.07) saturate(1.1) brightness(1.3) hue-rotate(-4deg) sepia(0.1) drop-shadow(0 0 0.5px #ffffff); }
        .status { 
    position: fixed; /* Changed from absolute to fixed */
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%); 
    background: rgba(0,0,0,0.9); 
    border: 2px solid var(--accent); 
    padding: 30px 60px; 
    font-size: 26px; 
    font-weight: 700; 
    text-align: center; 
    z-index: 100002; /* Higher than everything else */
    box-shadow: var(--glow); 
    display: none; /* Hidden by default */
}.spinner { width: 60px; height: 60px; border: 6px solid #333333; border-top: 6px solid var(--accent); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* --- NEXT EPISODE OVERLAY --- */
        .next-episode-btn {
    position: fixed; /* Fixed so it stays put even if player resizes */
    bottom: 80px;
    right: 40px; 
    background: var(--card-bg); 
    color: var(--text);
    padding: 15px 25px;
    border: 1px solid var(--accent); 
    border-radius: 12px;
    font-family: var(--font-primary);
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    z-index: 100002; 
    box-shadow: 0 10px 40px rgba(0,0,0,0.6); 
    
    /* Animation State: Hidden */
    opacity: 0;
    transform: translateY(30px) scale(0.9);
    pointer-events: none;
    transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
    
    /* Layout */
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
    min-width: 260px;
    backdrop-filter: blur(15px);
}

.update-success { color: #00ff41 !important; text-shadow: 0 0 10px #00ff41; }
.update-error { color: #e50914 !important; }

.next-episode-btn.visible {
    opacity: 1;
    transform: translateY(0) scale(1);
    pointer-events: auto;
}
.next-episode-btn:hover {
    background: var(--accent);
    color: #000; 
    box-shadow: 0 0 30px var(--glow);
    transform: scale(1.02) translateY(-2px);
}

.next-episode-btn:hover .next-ep-subtext {
    color: rgba(0,0,0,0.7);
}

.next-episode-btn.nav-focus {
    background: var(--accent);
    color: #000; 
    box-shadow: 0 0 30px var(--glow);
    transform: scale(1.05) translateY(-2px);
    outline: none;
}
.next-episode-btn.nav-focus .next-ep-subtext {
    color: rgba(0,0,0,0.7);
}

.next-ep-subtext {
    font-size: 11px;
    opacity: 0.7;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-secondary);
}

#nextEpTitle {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 240px;
}
        .seasons { 
    display: flex; 
    gap: 30px; 
    align-items: center; 
    justify-content: center; /* Center the dropdowns */
    flex-wrap: wrap; 
    margin: 0; 
    font-size: 20px; 
    background: var(--input-bg); /* Slightly darker to distinguish from info */
    border: 2px solid var(--border); 
    border-top: none; /* Connect to info tile above */
    padding: 20px 40px; 
    box-shadow: var(--glow); 
}
select { padding: 16px 32px; border: 2px solid var(--accent); background: var(--input-bg); color: var(--text); font-size: 20px; box-shadow: var(--glow); outline: none; }
        .fullscreen-btn, 
#autoplayToggle + .slider, 
#autoplayToggle {
    display: none !important;
}
        .episode-info { background: var(--card-bg); border: 2px solid var(--border); padding: 30px; margin: 0; box-shadow: var(--glow); }
        .server-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 25px; }
        .stat-item { background: var(--input-bg); border: 2px solid var(--border); padding: 25px; text-align: center; box-shadow: var(--glow); }
        .stat-label { color: var(--text-secondary); font-size: 18px; }
        .stat-value { font-weight: 700; font-size: 32px; margin-top: 10px; color: var(--accent); text-shadow: var(--glow); }

        #home, #grid, #detail { flex-grow: 1; min-height: 10px; padding-bottom: 60px; }
        .hidden { display: none !important; } 
        footer { text-align: center; padding: 20px; color: #444444; font-size: 16px; flex-shrink: 0; }
        
        /* --- Modal --- */
        .modal { position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: transparent; display: flex; justify-content: center; align-items: center; opacity: 0; visibility: hidden; transition: opacity 0.4s ease-in-out, background-color 0.4s ease-in-out, visibility 0.4s; }
        .modal.visible { opacity: 1; visibility: visible; background-color: var(--modal-backdrop-color); }
        .modal-content { background: var(--card-bg); border: 2px solid var(--accent); padding: 40px; box-shadow: var(--glow); position: relative; width: 90%; max-width: 600px; transform: scale(0.9); transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .modal.visible .modal-content { transform: scale(1); }
        .close { position: absolute; top: 15px; right: 25px; color: var(--text); font-size: 40px; font-weight: bold; cursor: pointer; transition: color 0.3s; outline: none; }
        .close:hover, .close:focus { color: var(--accent); }
        .blur-background { filter: blur(5px); }
        
        .setting-row { display: flex; justify-content: space-between; align-items: center; margin: 20px 0; padding-bottom: 20px; border-bottom: 1px dashed var(--border); }
        .setting-row:last-child { border-bottom: none; }
        .setting-label { font-size: 20px; font-weight: 700; color: var(--text); }
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent); }
        input:checked + .slider:before { transform: translateX(26px); }

        /* --- KEYBOARD STYLES --- */
        #keyboardModal .modal-content { 
            width: 80%; 
            max-width: 900px; 
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--accent);
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-height: 95vh;
            overflow: hidden; 
            scrollbar-width: none; 
            -ms-overflow-style: none;
        }
        
        #keyboardModal .modal-content::-webkit-scrollbar { display: none; }

        .simple-keyboard { 
            background-color: transparent !important; 
            width: 100%; 
            max-width: 1200px; 
        }
        
        .hg-row {
            display: flex;
            justify-content: center;
            gap: 10px; 
            margin-bottom: 10px;
        }

        .hg-button { 
            font-family: var(--font-primary, 'Consolas', monospace) !important; 
            background: var(--input-bg) !important; 
            color: var(--text) !important; 
            border: 1px solid var(--border) !important;
            border-bottom: 3px solid var(--border) !important; 
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5) !important;
            height: 60px !important;
            width: 60px !important; 
            flex: 0 0 60px !important; 
            font-size: 24px !important;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s ease-out;
            text-transform: lowercase !important; 
        }

        .hg-button.hg-activeButton, .hg-button:focus, .hg-button:hover { 
            background-color: var(--accent) !important; 
            color: #000 !important; 
            border-color: var(--accent) !important;
            transform: translateY(2px); 
            box-shadow: 0 0 15px var(--accent) !important;
            z-index: 10;
        }

        .hg-button-bksp { flex: 0 0 130px !important; font-size: 30px !important; }
        .hg-button-space { flex: 1 !important; max-width: 600px !important; font-size: 18px !important; letter-spacing: 3px; border-bottom: 3px solid var(--accent) !important; }
        .hg-button-enter { flex: 0 0 150px !important; background: var(--text) !important; color: #000 !important; font-weight: 800; }

        #keyboardInputDisplay { 
            width: 100%; 
            padding: 15px; 
            font-size: 40px; 
            background: transparent; 
            border: none; 
            border-bottom: 2px solid var(--accent); 
            color: var(--text); 
            font-family: var(--font-primary, 'Consolas', monospace); 
            text-align: center; 
            margin-bottom: 40px;
            text-shadow: 0 0 10px var(--accent);
        }
        @media (max-width: 768px) {
            header { flex-direction: column; gap: 20px; padding: 20px; }
            .header-left { flex-direction: column; gap: 20px; align-items: flex-start; max-width: 100%; }
            .search { width: 100%; max-width: 100%; }
            .hero { height: 50vh; }
            .hero-title { font-size: 48px; }
            .hero-desc { font-size: 20px; white-space: normal; height: auto; }
            .hero-desc.typing { width: 100%; animation: none; white-space: normal; overflow: visible; }
            .row-title { margin-left: 20px; font-size: 28px; }
            .carousel { padding: 50px 80px 80px; }
            .carousel-item { flex: 0 0 160px !important; }
            .detail-info-tile { 
    display: flex; 
    gap: 40px; 
    background: var(--card-bg); 
    border: 2px solid var(--border); 
    padding: 40px; 
    margin-bottom: 0; /* Remove bottom margin to connect with controls */
    box-shadow: var(--glow); 
    align-items: flex-start;
    width: 100%; /* Force full width matches player */
    box-sizing: border-box;
}
            .detail-poster-small { width: 100%; max-width: 300px; margin-bottom: 20px; }
            .player { height: 50vh; }
            .profile-title { font-size: 2rem; }
        }
    </style>
</head>
<body class="theme-console">

    <div id="smartLoader">
    <img id="loaderBackdrop" src="" alt="">
    <div class="loader-content">
        <div class="loader-spinner"></div>
        <div style="font-family: var(--font-primary); color: var(--accent); text-shadow: var(--glow); font-size: 24px; letter-spacing: 2px;">
            > INITIALIZING CINEMATIC SESSION...
        </div>
    </div>
</div>

    <div class="cursor-dot" id="cursorDot"></div>
    <div class="cursor-trail" id="cursorTrail1"></div>
    <div class="cursor-trail" id="cursorTrail2"></div>

    <div id="bootScreen" class="boot-screen visible">
        <div class="boot-logo">opentheatre</div>
        <div class="boot-loader"></div>
    </div>

    <div id="profileGate" class="profile-gate hidden">
        <h1 class="profile-title" id="profileTitle">who's watching?</h1>
        <div class="profile-container" id="profileContainer"></div>
        <div class="profile-manage-btn" id="manageBtn" tabindex="0" onclick="toggleManageMode()">manage profiles</div>
    </div>

    <div id="editProfileModal" class="edit-profile-modal">
        <div class="edit-profile-content">
            <h2 style="color:white; margin:0;">edit profile</h2>
            <div style="display:flex; gap:20px; align-items:center;">
                <div id="editAvatarPreview" class="profile-avatar" style="width:100px; height:100px; cursor:pointer;" onclick="openAvatarPicker()"></div>
                <div style="flex:1;">
                    <label style="color:#aaa; display:block; margin-bottom:5px;">profile name</label>
                    <input type="text" id="editNameInput" class="edit-input" placeholder="Name">
                </div>
            </div>
            <div style="color:#666; font-size:0.9rem;">> click avatar to change</div>
            <div class="setting-row" style="margin: 5px 0; border: none;">
                <div class="setting-label" style="font-size: 16px; color: #aaa;">set as main profile</div>
                <label class="switch">
                    <input type="checkbox" id="mainProfileToggle"> 
                    <span class="slider"></span>
                </label>
            </div>
            
            <div id="avatarPicker" class="hidden">
                <h3 style="color:var(--accent); margin:10px 0;">choose avatar</h3>
                <div class="avatar-picker-grid" id="avatarGrid"></div>
            </div>

            <div class="edit-buttons">
                <button class="btn-primary" onclick="saveProfileChanges()">save</button>
                <button class="btn-secondary" onclick="closeEditModal()">cancel</button>
                <button class="btn-danger" id="deleteProfileBtn" onclick="deleteCurrentProfile()">Delete</button>
            </div>
        </div>
    </div>

    

    <div class="main-content">
        <header>
            <div class="header-left">
                <div class="logo-wrapper">
                    <h1 class="logo" onclick="toggleLogoMenu()" tabindex="0">
                        <span>o</span><span>p</span><span>e</span><span>n</span><span>t</span><span>h</span><span>e</span><span>a</span><span>t</span><span>r</span><span>e</span>
                    </h1>
                    <div id="logoMenu" class="logo-menu">
                        <div class="logo-menu-item" onclick="profilePlaceholder(); toggleLogoMenu()" tabindex="0">profiles</div>
                        <div class="logo-menu-item" onclick="openSettings(); toggleLogoMenu()" tabindex="0">settings</div>
                        <div class="logo-menu-item" onclick="handleUpdateClick(); toggleLogoMenu()" tabindex="0">check for updates</div>
                        <div class="logo-menu-item" onclick="resetAllData(); toggleLogoMenu()" tabindex="0">reset data</div>
                    </div>
                </div>
                
                <div class="tabs">
                    <div class="tab active" onclick="showHome()" tabindex="0">home</div>
                    <div class="tab" onclick="switchTab('movie')" tabindex="0" data-view="movie">movies</div>
                    <div class="tab" onclick="switchTab('tv')" tabindex="0" data-view="tv">tv shows</div>
                    <div class="tab" onclick="switchTab('sports')" tabindex="0" data-view="sports">sports</div>
                </div>
            </div>
            <div class="search">
                <input type="text" id="searchInput" placeholder="> search movies & tv shows..." readonly onclick="openKeyboard()" onfocus="openKeyboard()" tabindex="0">
            </div>
        </header>

        <div id="home" class="home"></div>
        <div id="grid" class="grid hidden"></div>
        <div id="detail" class="detail hidden"> 
    
    <div class="player-container">
       <div id="nextEpBtn" class="next-episode-btn" onclick="forceNextEpisode()">
    <span class="next-ep-subtext" id="nextEpTimer">coming up</span>
    <span id="nextEpTitle">Loading...</span>
</div>
        <div id="status" class="status">
            <div class="spinner"></div>
            > initializing stream...
        </div>
        
        <div id="clickShield" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index: 9998; cursor: none;" onclick="hudTogglePlay()"></div>
        <iframe id="player" class="player" src="" frameborder="0" scrolling="no" allow="autoplay; fullscreen" allowfullscreen></iframe>
    </div>

    <div class="detail-info-tile">
        <div class="detail-poster-small">
            <img id="detailPoster" src="">
        </div>
        <div class="detail-text">
            <h2 id="title"></h2>
            <div class="metadata">
                <span id="rating">--</span>
                <span id="runtime">--</span>
            </div>
            <p class="detail-overview" id="overview"></p>
            <div id="castList" class="cast-list hidden">
                <h3>lead actors</h3>
            </div>
            
            <div id="episodeInfo" class="episode-info hidden" style="display:none;">
                <h3 id="episodeTitle"></h3> 
                <p class="episode-desc" id="episodeDesc"></p>
                <div class="server-stats">
                    <div id="duration">--</div>
                    <select id="serverSelect" onchange="manualServerSwitch(this.value)"></select>
                    <div id="quality">1080p+</div>
                </div>
            </div>
        </div>
    </div>

<div id="unifiedControls" class="tv-controls-container hidden">
        
        <div id="tvInputs" class="seasons">
            season: <select id="seasonSelect" tabindex="0"></select>
            episode: <select id="episodeSelect" tabindex="0"></select>
        </div>

        <div id="sportInputs" class="seasons" style="display:none;">
            server: <select id="sportSourceSelect" tabindex="0" onchange="switchSportSource(this.value)"></select>
        </div>

    </div>
    
    <footer>@rsrs 2025</footer>
</div>
    <div id="settingsModal" class="modal" onclick="if(event.target === this) closeSettings()">
        <div class="modal-content">
            <span class="close" onclick="closeSettings()" tabindex="0"></span>
            <h2>> stream preferences</h2>
            <div class="setting-row">
                <div class="setting-label">system theme</div>
                <select id="themeSelect" onchange="applyTheme(this.value)" tabindex="0">
                    <option value="console">CONSOLE (DEFAULT)</option>
                    <option value="matrix-green">MATRIX GREEN</option>
                    <option value="oled-black">PURE BLACK OLED</option>
                    <option value="light-mode">LIGHT MODE</option>
                    <option value="tokyo-night">TOKYO NIGHT</option>
                    <option value="cyberpunk-neon">CYBERPUNK NEON</option>
                    <option value="vaporwave">VAPORWAVE</option>
                    <option value="sunset">SUNSET ORANGE</option>
                    <option value="deep-blue">DEEP BLUE</option>
                    <option value="monochrome">MONOCHROME</option>
                    <option value="dark-mint">DARK MINT</option>
                    <option value="golden-ember">GOLDEN EMBER</option>
                </select>
            </div>
            <div class="setting-row">
                <div class="setting-label">primary stream quality</div>
                <select id="qualityPref" tabindex="0">
                    <option value="best">best quality (vidsrc priority)</option>
                    <option value="fast">fast load</option>
                    <option value="auto">auto balance</option>
                </select>
            </div>
            <div class="setting-row">
                <div class="setting-label">performance mode (reduce motion)</div>
                <label class="switch">
                    <input type="checkbox" id="perfModeToggle" onchange="togglePerfMode()"> 
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-row">
                <div class="setting-label">quality enhancement (experimental)</div>
                <label class="switch">
                    <input type="checkbox" id="aiUpscalingToggle" tabindex="0"> 
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </div>

    <div id="updateModal" class="modal" onclick="if(event.target === this) closeUpdateModal()">
    <div class="modal-content" style="text-align: center; max-width: 450px;">
        <span class="close" onclick="closeUpdateModal()" tabindex="0"></span>
        
        <h2 id="updateTitle">> system update</h2>
        
        <div id="updateSpinner" class="spinner" style="margin: 30px auto;"></div>
        
        <p id="updateStatusText" style="font-size: 20px; color: var(--text-secondary); margin-bottom: 30px;">
            initializing...
        </p>

        <div id="versionInfo" style="display:none; background: var(--input-bg); padding: 15px; border: 1px solid var(--border); margin-bottom: 25px;">
            <div style="color: #888; font-size: 14px;">your version:</div>
            <div id="currentVerDisplay" style="color: var(--text); font-size: 18px; font-weight: bold; margin-bottom: 10px;">--</div>
            
            <div style="color: var(--accent); font-size: 14px;">latest version:</div>
            <div id="newVerDisplay" style="color: var(--accent); font-size: 18px; font-weight: bold;">--</div>
        </div>

        <button id="updateActionBtn" class="btn-primary" onclick="handleUpdateAction()" style="display:none; width: 100%; padding: 15px;">
            update now
        </button>
    </div>
</div>


    <div id="infoModal" class="modal" onclick="if(event.target === this) closeInfoModal()">
        <div class="modal-content">
            <span class="close" onclick="closeInfoModal()" tabindex="0"></span>
            <h2 id="infoModalTitle">> loading...</h2>
            <div style="display:flex; gap:20px; margin-bottom:20px; color: var(--accent); font-weight:bold;">
                <span id="infoModalRating">--</span>
                <span id="infoModalRuntime">--</span>
            </div>
            <p id="infoModalDesc" style="font-size:18px; line-height:1.6; color:#ccc; margin-bottom:20px;"></p>
            <div id="infoModalCast" style="margin-top:20px; padding-top:20px; border-top:1px solid var(--border);"></div>
            <button class="btn-primary" onclick="playFromInfoModal()" style="margin-top:20px; width:100%; padding:15px; background:var(--accent); color:#000; font-weight:bold; border:none; cursor:pointer;">play now</button>
        </div>
    </div>

    <div id="globalContextMenu" class="context-menu">
        <div class="context-menu-item danger" id="cmUnwatch" onclick="handleMenuAction('unwatch')">unwatch</div>
        <div class="context-menu-item" onclick="handleMenuAction('block')">don't recommend</div>
        <div class="context-menu-item" onclick="handleMenuAction('info')">more info</div>
        <div class="context-menu-item" style="border-top:1px solid #333; margin-top:5px;" onclick="hideContextMenu()">close</div>
    </div>

    <div id="keyboardModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeKeyboard()" tabindex="0"></span>
            <h2>> search</h2>
            <input type="text" id="keyboardInputDisplay" placeholder="type here..." readonly>
            <div class="simple-keyboard"></div>
            <div style="margin-top: 20px; text-align: center;"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/simple-keyboard@latest/build/index.min.js"></script>

    <script>
        const API_KEY = "8def576f44c8bf7bdb915d1bd767c70c";
        const TMDB_BASE = "https://api.themoviedb.org/3";
        const IMG_BASE = "https://image.tmdb.org/t/p/original";
        const SLIDE_DURATION_MS = 16000; 

        // --- AVATAR & PROFILE CONFIG ---
        const LOCAL_AVATARS = Array.from({length: 8}, (_, i) => `avatar/${i + 1}.png`);
        let profiles = JSON.parse(localStorage.getItem('ot_profiles')) || [
            { id: 1, name: 'User', color: '#e50914', avatar: LOCAL_AVATARS[5] },
            { id: 2, name: 'Kids', color: '#ffa500', avatar: LOCAL_AVATARS[6] }
        ];

        
        
        let activeProfile = null;
        let isMenuOpen = false;
        let ignoreEnterUntilRelease = false; 
        let menuFocusIndex = 0;
        let lastFocusedCard = null; 
        let longPressTimer = null;
        let isLongPressActive = false;
        let longPressTriggered = false;
        let isManageMode = false;
        let editingProfileId = null;
        let isKeyboardScrolling = false; // The new lock
let scrollLockTimer = null;
let kickstartLock = false;

        // =================================================================
        // CURSOR LOGIC (Red Ball + Trail + Inactivity Hide)
        // =================================================================
        // =================================================================
// CURSOR LOGIC (Theme-Aware + Trail + Inactivity Hide)
// =================================================================
window.addEventListener('scroll', () => {
        if (window.scrollY > 10) {
            document.body.classList.add('scrolled-down');
        } else {
            document.body.classList.remove('scrolled-down');
        }
        resetIdleTimer(); // Scrolling also wakes up UI
    });

    // --- 2. CURSOR & HUD WAKE-UP LOGIC ---
    const cursorDot = document.getElementById('cursorDot');
    const trail1 = document.getElementById('cursorTrail1');
    const trail2 = document.getElementById('cursorTrail2');
    
    let mouseX = 0, mouseY = 0;
    let trail1X = 0, trail1Y = 0;
    let trail2X = 0, trail2Y = 0;
    let idleTimer = null;

    // Time before HUD vanishes (3 Seconds)
    const IDLE_TIMEOUT = 3000;

    function resetIdleTimer() {
        // Wake up UI
        if (!document.body.classList.contains('user-active')) {
            document.body.classList.add('user-active');
        }
        
        clearTimeout(idleTimer);
        idleTimer = setTimeout(() => {
            document.body.classList.remove('user-active');
        }, IDLE_TIMEOUT);
    }

    // --- INPUT LISTENERS (Mouse + Keyboard) ---
    document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
        resetIdleTimer();
    });
    
    // Wakes up on ANY key press
    document.addEventListener('keydown', resetIdleTimer);
    document.addEventListener('click', resetIdleTimer);

// =================================================================
    // UNIFIED INPUT MANAGER (Cursor + HUD + Keyboard)
    // =================================================================

    // 1. MOUSE MOVEMENT
    document.addEventListener('mousemove', (e) => {
        // Update Cursor Visuals
        mouseX = e.clientX;
        mouseY = e.clientY;
        const cursorDot = document.getElementById('cursorDot');
        if (cursorDot) cursorDot.style.transform = `translate(${mouseX - 6}px, ${mouseY - 6}px)`;

        // CRITICAL: Only wake HUD if we are NOT currently scrolling via keyboard
        if (window.scrollY < 50 && !isKeyboardScrolling) {
            wakeUpHUD();
        }
    });

    // 2. KEYBOARD INTERACTION
    document.addEventListener('keydown', (e) => {
        if (!document.body.classList.contains('viewing-mode')) return;

        const isUiVisible = document.body.classList.contains('user-active');
        const isLeavingPlayer = (e.key === 'ArrowDown' && navState.activeRow !== 0);

        // A. WAKE-UP GUARD (If hidden, first key just wakes up)
        if (!isUiVisible && window.scrollY < 50) {
            wakeUpHUD(); 
            e.preventDefault(); 
            e.stopPropagation();
            return; 
        }

        // B. SMART WAKE-UP (Keep awake unless we are leaving)
        if (window.scrollY < 50 && !isLeavingPlayer) {
            wakeUpHUD(); 
        }

        // C. Prevent Scroll for Nav Keys
        if (window.scrollY < 50) {
            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', ' ', 'Spacebar'].includes(e.key)) {
                e.preventDefault(); 
            }
        }

        handleRemoteNavigation(e);
    });

    // 3. SCROLL HANDLING
    document.addEventListener('scroll', () => {
        if (window.scrollY > 50) forceHideHUD(); // Instant hide
        else if (window.scrollY < 10) isKeyboardScrolling = false; // Reset lock at top
    });

// Smooth Trail Animation Loop





function animateCursor() {
    // Trail 1 follows mouse with slight delay (0.25 factor)
    trail1X += (mouseX - trail1X) * 0.25;
    trail1Y += (mouseY - trail1Y) * 0.25;
    trail1.style.transform = `translate(${trail1X - 6}px, ${trail1Y - 6}px)`;

    // Trail 2 follows Trail 1 with more delay (0.20 factor)
    trail2X += (trail1X - trail2X) * 0.2;
    trail2Y += (trail1Y - trail2Y) * 0.2;
    trail2.style.transform = `translate(${trail2X - 6}px, ${trail2Y - 6}px)`;

    requestAnimationFrame(animateCursor);
}
animateCursor();

        // --- CORE SYSTEM & BOOT ---
        document.addEventListener('DOMContentLoaded', () => {
     // --- 1. THE MODAL FIX (Ejector Seat) ---
     // Moves modals out of .main-content so they don't get blurred or stuck
     const modals = ['settingsModal', 'infoModal', 'globalContextMenu', 'keyboardModal', 'editProfileModal', 'updateModal'];
     modals.forEach(id => {
         const el = document.getElementById(id);
         if (el && el.parentElement !== document.body) {
             document.body.appendChild(el);
         }
     });

     // --- 2. Existing Boot Logic ---
     document.getElementById('qualityPref').value = qualityPref;
     document.getElementById('aiUpscalingToggle').checked = aiUpscalingEnabled;
     loadTheme();
     initSystem();
     history.replaceState({ view: 'home' }, '');
});

        function initSystem() {

            const bootScreen = document.getElementById('bootScreen'); 

    if(bootScreen) {
        bootScreen.style.display = 'none'; 
        bootScreen.classList.remove('visible');
    }

if(bootScreen) {
        bootScreen.style.display = 'none'; 
        bootScreen.classList.remove('visible');
    }

            
            if(bootScreen) bootScreen.style.display = 'none';

            const mainProfile = profiles.find(p => p.isMain);
            if (mainProfile) {
                console.log("Main Profile detected. Auto-logging in:", mainProfile.name);
                selectProfile(mainProfile);
            } else {
                const profileGate = document.getElementById('profileGate');
                renderProfiles();
                profileGate.classList.add('visible');
                profileGate.classList.remove('hidden');
                
                setTimeout(() => {
                    const first = document.querySelector('.profile-card');
                    if(first) first.focus();
                }, 100);
            }
        }

        // --- PROFILE LOGIC ---
        function renderProfiles() {
            const container = document.getElementById('profileContainer');
            const title = document.getElementById('profileTitle');
            const btn = document.getElementById('manageBtn');
            container.innerHTML = '';
            title.textContent = isManageMode ? "manage profiles:" : "who's watching?";
            btn.textContent = isManageMode ? "done" : "manage profiles";
            const gate = document.getElementById('profileGate');
            if(isManageMode) gate.classList.add('manage-mode');
            else gate.classList.remove('manage-mode');

            profiles.forEach(p => {
                const div = document.createElement('div');
                div.className = 'profile-card';
                div.tabIndex = 0;
                let editOverlay = isManageMode ? `<div class="profile-edit-icon"></div>` : '';
                div.innerHTML = `<div class="profile-avatar" style="background-image: url('${p.avatar}'); border-color: ${p.color}">${editOverlay}</div><div class="profile-name">${p.name}</div>`;
                div.onclick = () => { if (isManageMode) openEditProfile(p); else selectProfile(p); };
                div.onkeydown = (e) => { if(e.key === 'Enter') { if (isManageMode) openEditProfile(p); else selectProfile(p); }};
                container.appendChild(div);
            });

            if (isManageMode && profiles.length < 5) {
                const addDiv = document.createElement('div');
                addDiv.className = 'profile-card';
                addDiv.tabIndex = 0;
                addDiv.innerHTML = `<div class="profile-avatar" style="display:flex; justify-content:center; align-items:center; background:#333; font-size:50px; color:#666;">+</div><div class="profile-name">add profile</div>`;
                addDiv.onclick = () => createNewProfile();
                addDiv.onkeydown = (e) => { if(e.key === 'Enter') createNewProfile(); };
                container.appendChild(addDiv);
            }
        }

        function toggleManageMode() {
            isManageMode = !isManageMode;
            renderProfiles();
        }

        function findNextTarget() {
    const sSelect = document.getElementById('seasonSelect');
    const eSelect = document.getElementById('episodeSelect');
    
    // Safety: If we are in movies mode, these won't exist/be visible
    if (!sSelect || !eSelect || sSelect.offsetParent === null) return null;

    const currEpIdx = eSelect.selectedIndex;
    const currSeaIdx = sSelect.selectedIndex;

    // SCENARIO 1: Next Episode in Current Season
    if (currEpIdx < eSelect.options.length - 1) {
        return {
            type: 'episode',
            name: eSelect.options[currEpIdx + 1].text,
            val: eSelect.options[currEpIdx + 1].value
        };
    } 
    // SCENARIO 2: Next Season (Start at Ep 1)
    else if (currSeaIdx < sSelect.options.length - 1) {
        return {
            type: 'season',
            name: `Season ${parseInt(sSelect.options[currSeaIdx + 1].text) || (currSeaIdx + 2)}`, 
            val: sSelect.options[currSeaIdx + 1].value
        };
    }
    
    return null; // End of Series
}

function forceNextEpisode() {
    const target = findNextTarget();
    if (!target) return;

    // Hide button immediately to prevent double clicks
    document.getElementById('nextEpBtn').classList.remove('visible');
    
    if (target.type === 'episode') {
        const eSelect = document.getElementById('episodeSelect');
        eSelect.selectedIndex = eSelect.selectedIndex + 1;
        eSelect.dispatchEvent(new Event('change'));
    } 
    else if (target.type === 'season') {
        const sSelect = document.getElementById('seasonSelect');
        sSelect.selectedIndex = sSelect.selectedIndex + 1;
        sSelect.dispatchEvent(new Event('change')); 
        // Note: The change event on season will automatically trigger loadEpisodes -> Ep 1
    }
}

        function selectProfile(profile) {
            activeProfile = profile;
            const historyKey = `ot_history_${profile.id}`;
            continueWatching = JSON.parse(localStorage.getItem(historyKey) || '[]');
            const profileGate = document.getElementById('profileGate');
            profileGate.style.transform = 'scale(1.1)';
            profileGate.style.opacity = '0';
            setTimeout(() => {
                profileGate.classList.remove('visible');
                profileGate.classList.add('hidden');
                profileGate.style.transform = 'none'; 
                showHome(false);
                history.replaceState({ view: 'home' }, '');
            }, 300);
        }

        function profilePlaceholder() {
            localStorage.removeItem('ot_active_profile_id');
            const profileGate = document.getElementById('profileGate');
            const menu = document.getElementById('logoMenu');
            menu.classList.remove('visible'); 
            stopPlayer(); 
            isManageMode = false;
            profileGate.classList.remove('hidden');
            void profileGate.offsetWidth; 
            profileGate.classList.add('visible');
            profileGate.style.opacity = '1';
            renderProfiles();
            setTimeout(() => { const first = document.querySelector('.profile-card'); if(first) first.focus(); }, 100);
        }

        let tempAvatar = '';

        function openEditProfile(profile) {
            editingProfileId = profile.id;
            tempAvatar = profile.avatar;
            document.getElementById('editNameInput').value = profile.name;
            document.getElementById('editAvatarPreview').style.backgroundImage = `url('${profile.avatar}')`;
            const toggle = document.getElementById('mainProfileToggle');
            if(toggle) toggle.checked = !!profile.isMain;
            const delBtn = document.getElementById('deleteProfileBtn');
            delBtn.style.display = profiles.length > 1 ? 'block' : 'none';
            document.getElementById('avatarPicker').classList.add('hidden'); 
            document.getElementById('editProfileModal').classList.add('visible');
            document.getElementById('editNameInput').focus();
        }

        function createNewProfile() {
            const newId = Date.now();
            const newProfile = { id: newId, name: 'New Profile', color: '#ffffff', avatar: LOCAL_AVATARS[Math.floor(Math.random() * LOCAL_AVATARS.length)] };
            profiles.push(newProfile);
            saveProfilesToStorage();
            openEditProfile(newProfile);
        }

        function closeEditModal() {
            document.getElementById('editProfileModal').classList.remove('visible');
            editingProfileId = null;
        }

        function openAvatarPicker() {
            const picker = document.getElementById('avatarPicker');
            const grid = document.getElementById('avatarGrid');
            grid.innerHTML = '';
            LOCAL_AVATARS.forEach(url => {
                const div = document.createElement('div');
                div.className = 'avatar-option';
                div.style.backgroundImage = `url('${url}')`;
                if(url === tempAvatar) div.classList.add('selected');
                div.onclick = () => {
                    tempAvatar = url;
                    document.getElementById('editAvatarPreview').style.backgroundImage = `url('${url}')`;
                    document.querySelectorAll('.avatar-option').forEach(el => el.classList.remove('selected'));
                    div.classList.add('selected');
                };
                grid.appendChild(div);
            });
            picker.classList.remove('hidden');
        }


        function saveProfileChanges() {
            if (!editingProfileId) return;
            const newName = document.getElementById('editNameInput').value.trim() || 'User';
            const isMain = document.getElementById('mainProfileToggle').checked;
            const index = profiles.findIndex(p => p.id === editingProfileId);
            if (index !== -1) {
                profiles[index].name = newName;
                profiles[index].avatar = tempAvatar;
                if (isMain) {
                    profiles.forEach(p => p.isMain = false);
                    profiles[index].isMain = true;
                } else {
                    profiles[index].isMain = false;
                }
                saveProfilesToStorage();
            }
            closeEditModal();
            renderProfiles();
        }

        function deleteCurrentProfile() {
            if (!editingProfileId) return;
            if (confirm("Are you sure you want to delete this profile? History will be lost.")) {
                profiles = profiles.filter(p => p.id !== editingProfileId);
                saveProfilesToStorage();
                closeEditModal();
                renderProfiles();
            }
        }

        function saveProfilesToStorage() { localStorage.setItem('ot_profiles', JSON.stringify(profiles)); }

        const PROVIDERS = [
            { name: "VidLink (UpCloud/VidCloud)", url: (id, tv, s, e) => tv ? `https://vidlink.pro/tv/${id}/${s}/${e}` : `https://vidlink.pro/movie/${id}` },
            { name: "VidSrc.to (Fast)", url: (id, tv, s, e) => tv ? `https://vidsrc.to/embed/tv/${id}/${s}/${e}` : `https://vidsrc.to/embed/movie/${id}` },
            { name: "VidSrc.net (Backup)", url: (id, tv, s, e) => tv ? `https://vidsrc.net/embed/tv/${id}/${s}/${e}` : `https://vidsrc.net/embed/movie/${id}` },
            { name: "AutoEmbed", url: (id, tv, s, e) => tv ? `https://autoembed.co/tv/tmdb/${id}-${s}-${e}` : `https://autoembed.co/movie/tmdb/${id}` },
            { name: "VidSrc.cc", url: (id, tv, s, e) => tv ? `https://vidsrc.cc/v2/embed/tv/${id}/${s}/${e}` : `https://vidsrc.cc/v2/embed/movie/${id}` },
            { name: "SuperEmbed", url: (id, tv, s, e) => tv ? `https://multiembed.mov/directstream.php?video_id=${id}&tmdb=1&s=${s}&e=${e}` : `https://multiembed.mov/directstream.php?video_id=${id}&tmdb=1` },
            { name: "2Embed", url: (id, tv, s, e) => tv ? `https://www.2embed.cc/embedtv/${id}&s=${s}&e=${e}` : `https://www.2embed.cc/embed/${id}` },
            { name: "SmashyStream", url: (id, tv, s, e) => tv ? `https://smashystream.com/tv/${id}/${s}/${e}` : `https://smashystream.com/embed/movie/${id}` }
        ];

        let currentType = 'movie';
        let currentId = null;
        let currentSeason = 1;
        let currentEpisode = 1;
        let currentSeriesRuntime = null;
        let currentProviderName = "Unknown";
        let loadStartTime = 0;
        let currentVideoTotalRuntime = 3600; 
        
        let qualityPref = localStorage.getItem('qualityPref') || 'best';
        let aiUpscalingEnabled = localStorage.getItem('aiUpscalingEnabled') === 'true';
        let performanceMode = localStorage.getItem('ot_perf') === 'true';
        let autoplayEnabled = localStorage.getItem('ot_autoplay') === 'true'; 
        
        // --- KEYBOARD SETUP ---
        let keyboard;
        function initKeyboard() {
            const Keyboard = window.SimpleKeyboard.default;
            keyboard = new Keyboard({
                onChange: input => onChange(input),
                onKeyPress: button => onKeyPress(button),
                physicalKeyboardHighlight: true,
                physicalKeyboard: false, 
                layout: { 'default': [ '1 2 3 4 5 6 7 8 9 0', 'q w e r t y u i o p', 'a s d f g h j k l {bksp}', 'z x c v b n m . - _', '{space} {enter}' ] },
                display: { '{bksp}': '', '{enter}': 'SEARCH', '{space}': 'SPACE' },
                buttonTheme: [ { class: "hg-highlight", buttons: "{enter} {space}" } ]
            });
        }
        function onChange(input) { document.querySelector("#keyboardInputDisplay").value = input; }
        function onKeyPress(button) { if (button === "{enter}") performSearchFromKeyboard(); }
        function openKeyboard() {
            document.getElementById('keyboardModal').classList.add('visible');
            document.querySelector('.main-content').classList.add('blur-background');
            if (!keyboard) initKeyboard();
            keyboard.setInput(""); 
            document.querySelector("#keyboardInputDisplay").value = "";
            setTimeout(() => {
                const keys = document.querySelectorAll('.hg-button');
                keys.forEach(k => k.setAttribute('tabindex', '0'));
                const firstKey = document.querySelector('.hg-button[data-skbtn="q"]');
                if(firstKey) firstKey.focus();
            }, 50);
        }
        function closeKeyboard() {
            document.getElementById('keyboardModal').classList.remove('visible');
            document.querySelector('.main-content').classList.remove('blur-background');
        }
        function performSearchFromKeyboard() {
            const query = document.getElementById('keyboardInputDisplay').value;
            if (query) {
                document.getElementById('searchInput').value = query;
                closeKeyboard();
                search(true).then(() => {
                    setTimeout(() => { const firstResult = document.querySelector('.grid-item'); if (firstResult) focusItem(firstResult); }, 200);
                });
            }
        }

        const searchInputText = "> search movies & tv shows...";
        document.getElementById("searchInput").placeholder = searchInputText; 

        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        window.onpopstate = function(event) {
            if (event.state) {
                if (event.state.view === 'home') showHome(false); 
                else if (event.state.view === 'grid') switchTab(event.state.type, false);
                else if (event.state.view === 'detail') showDetail(event.state.id, event.state.type, event.state.season, event.state.episode, false);
            } else showHome(false);
        };

        function loadTheme() {
            const savedTheme = localStorage.getItem('ot_theme');
            if (savedTheme) { applyTheme(savedTheme); document.getElementById('themeSelect').value = savedTheme; } 
            else applyTheme('console');
        }
        
        function applyTheme(themeName) {
            document.body.className = '';
            document.body.classList.add(`theme-${themeName}`);
            localStorage.setItem('ot_theme', themeName);
        }

        let continueWatching = [];
        let blockedShows = JSON.parse(localStorage.getItem('ot_blockedShows') || '[]');
        let currentPage = 1;
        let currentQuery = '';
        let currentAction = 'trending';

        function saveProgress(id, type, season = null, episode = null, time = 0, totalRuntime = currentVideoTotalRuntime) {
            if (!activeProfile) return; 
            const key = `${type}_${id}${season ? `_s${season}e${episode}` : ''}`;
            const entry = { key, id, type, season, episode, time, timestamp: Date.now(), total_runtime: totalRuntime };
            const index = continueWatching.findIndex(i => i.key === key);
            const completionThreshold = totalRuntime * 0.95; 

            if (time < 1 || time >= completionThreshold) { if (index > -1) continueWatching.splice(index, 1); } 
            else { if (index > -1) continueWatching[index] = entry; else continueWatching.push(entry); }
            continueWatching.sort((a, b) => b.timestamp - a.timestamp);
            continueWatching = continueWatching.slice(0, 50);
            localStorage.setItem(`ot_history_${activeProfile.id}`, JSON.stringify(continueWatching));
        }

        function getProviderOrder() {
            if (qualityPref === 'best') return [0, 1, 2, 9, 3, 5, 8, 4, 7, 6]; 
            if (qualityPref === 'fast') return [7, 4, 3, 1, 9, 5, 8, 2, 0, 6]; 
            return [0, 1, 4, 3, 9, 2, 7, 5, 8, 6]; 
        }

        function setStatus(text, loading = false) {
            const status = document.getElementById('status');
            status.innerHTML = loading ? `<div class="spinner"></div>${text}` : text;
            status.style.display = 'block';
        }

        function hideStatus() { document.getElementById('status').style.display = 'none'; }

        function updateServerStats() {
            const select = document.getElementById('serverSelect');
            // Populate stats if needed
            select.innerHTML = '';
            PROVIDERS.forEach((p, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.text = p.name.toLowerCase();
                select.appendChild(opt);
            });
            
            for(let i=0; i<select.options.length; i++) {
                if(select.options[i].text.toLowerCase().includes(currentProviderName.toLowerCase())) { select.selectedIndex = i; break; }
            }
        }

        function manualServerSwitch(index) {
            const idx = parseInt(index);
            const provider = PROVIDERS[idx] || PROVIDERS[0];
            const providerName = provider.name;
            const url = provider.url(currentId, currentType === 'tv', currentSeason, currentEpisode);
            document.getElementById('player').removeAttribute('sandbox');
            currentProviderName = providerName || "unknown";
            setStatus(`connecting to ${currentProviderName}...`, true);
            const player = document.getElementById('player');
            player.src = url;
            player.onload = () => { hideStatus(); };
        }

        function populateServerList() {
    const select = document.getElementById('serverSelect');
    if(!select) return;
    
    // Clear any "Live" junk or empty states
    select.innerHTML = ''; 
    
    // Add your VOD Providers (VidLink, VidSrc, etc.)
    PROVIDERS.forEach((p, index) => {
        const opt = document.createElement('option');
        opt.value = index;
        opt.text = p.name.toLowerCase();
        select.appendChild(opt);
    });
}

        let playbackStartTime = 0;
        let fallbackInterval = null;

        function tryProvider(indices, idx = 0) {
            if (idx >= indices.length) { setStatus("no streams available  try another title."); return; }
            const pIdx = indices[idx];
            currentProviderName = PROVIDERS[pIdx].name;
            setStatus(`loading ${currentProviderName}...`, true);
            loadStartTime = Date.now();
            const url = PROVIDERS[pIdx].url(currentId, currentType === 'tv', currentSeason, currentEpisode); 
            const player = document.getElementById('player');
            player.src = url;
            const timeout = setTimeout(() => tryProvider(indices, idx + 1), 7000); 
            player.onload = () => {
                clearTimeout(timeout);
                setTimeout(() => { hideStatus(); updateServerStats(); setupResumeTracking(); player.focus(); }, 2000);
            };
        }

        function updatePlayerQuality() {
            const player = document.getElementById('player');
            if (aiUpscalingEnabled) player.classList.add('quality-enhanced'); 
            else player.classList.remove('quality-enhanced');
        }

        function toggleFullscreen() {
            const player = document.getElementById('player');
            if (player.requestFullscreen) player.requestFullscreen();
            else if (player.webkitRequestFullscreen) player.webkitRequestFullscreen();
            else if (player.msRequestFullscreen) player.msRequestFullscreen();
        }

        function startStreaming() {
// 1. LOCK DOWN NAVIGATION
    kickstartLock = true;
    console.log(" Kickstart Lock Engaged");
    setTimeout(() => { kickstartLock = false; }, 3500); // Safety release

    window.scrollTo({ top: 0, behavior: 'smooth' });
    window.ipcRenderer.send('reset-stream-active');
    
    // --- FIX: METADATA FALLBACK INITIALIZATION ---
    // If TMDB says it's 42 mins (2520s), we start with that.
    // If main.js returns 0 later, we IGNORE it.
    localState.duration = currentVideoTotalRuntime || 3600; 
    localState.currentTime = 0;
    localState.playing = true; // Assume play starts immediately
    localState.lastTick = Date.now();
    
    // Force immediate UI update so user sees "00:00 / 42:00"
    updateHUDVisuals(); 
    // ---------------------------------------------

    playbackStartTime = Date.now();
    document.getElementById('nextEpBtn').classList.remove('visible');
    
    saveProgress(currentId, currentType, currentSeason, currentEpisode, 1, currentVideoTotalRuntime);
    updatePlayerQuality(); 
    startFocusSentinel();
    
    const order = getProviderOrder();
    tryProvider(order);
            if (fallbackInterval) clearInterval(fallbackInterval);
            fallbackInterval = setInterval(() => {
                const elapsedSeconds = Math.floor((Date.now() - playbackStartTime) / 1000);
                if (elapsedSeconds % 5 === 0) saveProgress(currentId, currentType, currentSeason, currentEpisode, elapsedSeconds, currentVideoTotalRuntime);
                if (currentType === 'tv') {
                    const remaining = currentVideoTotalRuntime - elapsedSeconds;
                    if (remaining <= 75 && remaining > -10) { 
                         const btn = document.getElementById('nextEpBtn');
                         if (!btn.classList.contains('visible')) btn.classList.add('visible');
                         if (autoplayEnabled && remaining <= 2 && remaining > 0) {
                             playbackStartTime = Date.now() + 100000; 
                             nextEpisode();
                         }
                    }
                }
            }, 1000);
        }

        function setupResumeTracking() {
            const player = document.getElementById('player');
            const key = `${currentType}_${currentId}${currentSeason ? `_s${currentSeason}e${currentEpisode}` : ''}`;
            const saved = continueWatching.find(c => c.key === key);
            if (saved && saved.time > 5) { 
                setTimeout(() => { try { player.contentWindow.postMessage(JSON.stringify({action: 'seek', time: saved.time}), '*'); } catch (e) { } }, 4000);
            }
            setInterval(() => { try { player.contentWindow.postMessage(JSON.stringify({action: 'getTime'}), '*'); } catch (e) {} }, 10000);
        }

        window.addEventListener('message', (e) => {
            try {
                const data = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;
                if (data.action === 'time' && data.time !== undefined) {
                    const time = Math.floor(data.time);
                    const duration = data.duration || currentVideoTotalRuntime;
                    const remaining = duration - time;
                    if (time > 1) saveProgress(currentId, currentType, currentSeason, currentEpisode, time, duration);
                    if (currentType === 'tv' && remaining <= 75 && remaining > 0) {
                        const btn = document.getElementById('nextEpBtn');
                        if (!btn.classList.contains('visible')) {
                            btn.classList.add('visible');
                            if (autoplayEnabled && remaining < 5) nextEpisode();
                        }
                    } else {
                        document.getElementById('nextEpBtn').classList.remove('visible');
                    }
                }
            } catch (e) {}
        });

        function stopPlayer() {

            kickstartLock = false;
            const player = document.getElementById('player');
            player.src = '';
            player.classList.remove('quality-enhanced'); 
            if (slideInterval) clearInterval(slideInterval);
            if (fallbackInterval) clearInterval(fallbackInterval);
            currentVideoTotalRuntime = 3600; 
        }

        

        window.addEventListener('beforeunload', stopPlayer);

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    if (entry.target.classList.contains('row')) entry.target.querySelectorAll('.carousel-item').forEach((item) => item.classList.add('visible'));
                    else if (entry.target.classList.contains('grid-item')) entry.target.classList.add('visible');
                    else if (entry.target.id === 'detail') entry.target.classList.add('visible');
                    else if (entry.target.id === 'loadMoreSentinel') loadMoreContent();
                    if (entry.target.id !== 'loadMoreSentinel') observer.unobserve(entry.target);
                }
            });
        }, { threshold: 0.1 });

        function renderCast(cast) {
            const castListDiv = document.getElementById('castList');
            castListDiv.classList.remove('hidden');
            let castHTML = '<h3>lead actors</h3>';
            cast.slice(0, 5).forEach(member => {
                const characterName = member.character || 'N/A';
                const nameText = member.name.length > 20 ? member.name.substring(0, 20) + '...' : member.name;
                castHTML += `<div class="cast-item">${nameText}<span class="character">as ${characterName.length > 20 ? characterName.substring(0, 20) + '...' : characterName}</span></div>`;
            });
            castListDiv.innerHTML = castHTML;
        }

        // =================================================================
// THE FOCUS SENTINEL (The Fix)
// =================================================================
let focusSentinelInterval = null;

function startFocusSentinel() {
    if (focusSentinelInterval) clearInterval(focusSentinelInterval);

    console.log(" Focus Sentinel Active");

    focusSentinelInterval = setInterval(() => {
        if (!document.body.classList.contains('viewing-mode')) {
            stopFocusSentinel();
            return;
        }

        const active = document.activeElement;
        
        // --- CHANGE: Added 'nextEpBtn' to whitelist ---
        const isSafe = active && (
            active.id === 'hudPlayPause' ||
            active.id === 'hudRewind' ||
            active.id === 'hudForward' ||
            active.id === 'hudBackBtn' ||
            active.id === 'seasonSelect' ||
            active.id === 'episodeSelect' ||
            active.id === 'hudProgressContainer' ||
            active.id === 'nextEpBtn' // <--- CRITICAL FIX
        );

        if (!isSafe) {
            // Force focus back if we drifted to body/iframe
            const playBtn = document.getElementById('hudPlayPause');
            if (playBtn) {
                playBtn.focus({ preventScroll: true });
                if (!playBtn.classList.contains('nav-focus')) {
                    highlightElement(playBtn);
                }
            }
        }
    }, 200); 
}

function stopFocusSentinel() {
    if (focusSentinelInterval) {
        clearInterval(focusSentinelInterval);
        focusSentinelInterval = null;
        console.log(" Focus Sentinel Stopped");
    }
}
        
        async function renderCarousel(title, items, container, isResume = false) {
            if (!items || items.length === 0) return;
            const row = document.createElement('div');
            row.className = 'row';
            row.innerHTML = `<div class="row-title">${title}</div>`;
            const carouselContainer = document.createElement('div');
            carouselContainer.className = 'carousel-container';
            const carousel = document.createElement('div');
            carousel.className = 'carousel';
            enableMouseEdgeScrolling(carousel);
            
            const fragment = document.createDocumentFragment();
            items.forEach((item, i) => {
                if (!item.poster_path && !isResume) return;
                const div = document.createElement('div');
                div.className = 'carousel-item';
                div.tabIndex = 0;
                // DOMINO EFFECT PRESERVED
                div.style.transitionDelay = `${i * 50}ms`; 
                const id = item.id;
                const type = item.media_type || (item.title ? 'movie' : 'tv');
                let imgUrl = item.poster_path;
                let titleText = item.title || item.name;
                if (isResume && !imgUrl) imgUrl = item.poster_path; 
                if (imgUrl) {
                    div.innerHTML = `<div class="more-options-btn" onclick="showContextMenu(event, ${id}, '${type}')"></div><img src="${IMG_BASE}${imgUrl}" loading="lazy" decoding="async" alt="${titleText}"><div class="carousel-item-title">${titleText}</div>${isResume ? `<div class="progress-bar" style="width: ${Math.random() * 90}%"></div>` : ''}`;
                    div.onclick = () => {
    // CHECK: Do we have resume data? (S2 E3)
    if (item.resume_entry && item.resume_entry.season) {
        console.log(` Resuming ${titleText} at S${item.resume_entry.season}E${item.resume_entry.episode}`);
        showDetail(id, type, item.resume_entry.season, item.resume_entry.episode);
    } else {
        // Default (Start from scratch)
        showDetail(id, type);
    }
};
                    fragment.appendChild(div);
                }
            });
            carousel.appendChild(fragment);
            carouselContainer.appendChild(carousel);
            row.appendChild(carouselContainer);
            requestAnimationFrame(() => { container.appendChild(row); observer.observe(row); });
        }

        function calculateRecommendationSources() {
            const TV_WEIGHT = 0.7; const RECENCY_WEIGHT = 0.3; const NOW = Date.now(); const ONE_MONTH_MS = 30 * 24 * 60 * 60 * 1000;
            const uniqueWatchedTV = continueWatching.filter(c => c.type === 'tv' && !blockedShows.includes(c.id)).reduce((map, obj) => {
                    const existing = map.get(obj.id);
                    if (existing) { existing.time += obj.time; existing.timestamp = Math.max(existing.timestamp, obj.timestamp); } else map.set(obj.id, { id: obj.id, time: obj.time, timestamp: obj.timestamp });
                    return map;
                }, new Map());
            const watchedTV = Array.from(uniqueWatchedTV.values());
            if (watchedTV.length === 0) return [];
            const maxTime = watchedTV.reduce((max, c) => Math.max(max, c.time), 0);
            return watchedTV.map(c => {
                    const normalizedTime = maxTime > 0 ? c.time / maxTime : 0;
                    const timeDiff = NOW - c.timestamp;
                    const normalizedRecency = Math.max(0, 1 - (timeDiff / ONE_MONTH_MS)); 
                    c.score = (normalizedTime * TV_WEIGHT) + (normalizedRecency * RECENCY_WEIGHT);
                    return c;
                }).sort((a, b) => b.score - a.score).slice(0, 5).map(c => c.id);
        }

        async function loadSimilarShows(container) {
            let allRecommendations = new Set();
            const sourceIds = calculateRecommendationSources();
            if (sourceIds.length === 0) return;
            const alreadyWatchedIds = new Set(continueWatching.map(c => c.id.toString()));
            const blockedIds = new Set(blockedShows.map(id => id.toString()));
            const addItemToRecs = (item) => {
                const idStr = item.id.toString();
                if (item.media_type === 'tv' && !alreadyWatchedIds.has(idStr) && !blockedIds.has(idStr) && item.poster_path) allRecommendations.add(item);
            };
            const topTwoSources = sourceIds.slice(0, 2);
            for (const id of topTwoSources) {
                const recRes = await fetch(`${TMDB_BASE}/tv/${id}/recommendations?api_key=${API_KEY}&language=en-US`);
                if (recRes.ok) { const data = await recRes.json(); data.results.slice(0, 10).forEach(addItemToRecs); }
            }
            for (const id of sourceIds) {
                const similarRes = await fetch(`${TMDB_BASE}/tv/${id}/similar?api_key=${API_KEY}&language=en-US`);
                if (similarRes.ok) { const data = await similarRes.json(); data.results.slice(0, 15).forEach(addItemToRecs); }
            }
            const recommendedArray = Array.from(allRecommendations);
            if (recommendedArray.length < 10 && sourceIds.length > 0) { 
                const mostWatchedId = sourceIds[0];
                const detailRes = await fetch(`${TMDB_BASE}/tv/${mostWatchedId}?api_key=${API_KEY}&language=en-US`);
                if (detailRes.ok) {
                    const detailData = await detailRes.json();
                    const genres = detailData.genres.map(g => g.id).join(',');
                    const discoverRes = await fetch(`${TMDB_BASE}/discover/tv?api_key=${API_KEY}&language=en-US&sort_by=vote_count.desc&with_genres=${genres}`);
                    if (discoverRes.ok) { const discoverData = await discoverRes.json(); discoverData.results.slice(0, 20).forEach(addItemToRecs); }
                }
            }
            const finalRecommendations = Array.from(allRecommendations).sort((a, b) => (b.popularity || 0) - (a.popularity || 0)).slice(0, 20);
            if (finalRecommendations.length > 0) renderCarousel(`> top recommendations from your advanced viewing profile`, finalRecommendations, container);
        }

       function toggleLogoMenu() {
            const menu = document.getElementById('logoMenu');
            const logo = document.querySelector('.logo');
            menu.classList.toggle('visible');
            if (menu.classList.contains('visible')) { setTimeout(() => { const firstItem = menu.querySelector('.logo-menu-item'); if(firstItem) firstItem.focus(); }, 50); } else logo.focus();
        }

        function resetAllData() {
            if (confirm("WARNING: This will erase all viewing history, progress, and settings. Are you sure you want to proceed?")) {
                localStorage.clear();
                window.location.reload();
            }
        }

        const typewriterText = "> system online. continue watching or initiate new stream...";
        let typewriterTimeout = null;
        function startTypewriter(elementId, text) {
            const el = document.getElementById(elementId);
            if (!el) return;
            clearTimeout(typewriterTimeout);
            el.textContent = text; 
            el.classList.add('typing');
            el.classList.remove('typed');
            const totalDuration = 2300; 
            typewriterTimeout = setTimeout(() => { el.classList.remove('typing'); el.classList.add('typed'); }, totalDuration);
        }

        let heroSlides = [];
        let currentSlideIndex = 0;
        let slideInterval = null;
        let currentLayer = 1;


        Element.prototype.requestFullscreen = function() { console.log("Blocked fullscreen request"); };
Element.prototype.webkitRequestFullscreen = function() { };
Element.prototype.mozRequestFullScreen = function() { };
Element.prototype.msRequestFullscreen = function() { };

        function setupLayer(layerElement, imageURL) {
            layerElement.style.backgroundImage = `url('${imageURL}')`;
            layerElement.style.animation = 'none'; 
            layerElement.offsetHeight; 
            layerElement.style.animation = `imagePanZoom 16s linear forwards`; 
        }

        function updateHeroBackground() {
            if (heroSlides.length === 0) return;
            const nextIndex = (currentSlideIndex + 1) % heroSlides.length;
            const nextImageURL = heroSlides[nextIndex];
            const activeLayer = document.querySelector(`.layer-${currentLayer}`);
            const nextLayerNum = currentLayer === 1 ? 2 : 1;
            const nextLayer = document.querySelector(`.layer-${nextLayerNum}`);
            setupLayer(nextLayer, nextImageURL);
            activeLayer.classList.remove('active');
            nextLayer.classList.add('active');
            currentLayer = nextLayerNum;
            currentSlideIndex = nextIndex;
        }

        async function loadHeroSlides() {
            const home = document.getElementById('home');
            const heroHTML = `
                <div class="hero-container">
                    <div class="hero-content">
                        <h1 class="hero-title">opentheatre</h1>
                        <p class="hero-desc" id="heroDesc"></p>
                    </div>
                    <div class="hero">
                        <div class="hero-bg-layer layer-1"></div>
                        <div class="hero-bg-layer layer-2"></div>
                        <div class="fading-overlay"></div>
                    </div>
                </div>
            `;
            if (!document.querySelector('.hero-container')) { home.innerHTML = heroHTML + home.innerHTML; startTypewriter('heroDesc', typewriterText); }
            
            heroSlides = [];
            currentSlideIndex = 0;
            currentLayer = 1;
            
            if (continueWatching.length > 0) {
                const uniqueWatched = continueWatching.reduce((acc, current) => { if (!acc.find(item => item.id === current.id)) { acc.push(current); } return acc; }, []);
                const promises = uniqueWatched.map(async cw => {
                    const res = await fetch(`${TMDB_BASE}/${cw.type}/${cw.id}/images?api_key=${API_KEY}`);
                    if (res.ok) { const images = await res.json(); return (images.backdrops || []).slice(0, 5).map(b => IMG_BASE + b.file_path); }
                    return [];
                });
                const watchedBackdrops = (await Promise.all(promises)).flat().filter(Boolean);
                
                if (watchedBackdrops.length > 0) {
                    heroSlides = watchedBackdrops.sort(() => Math.random() - 0.5);
                    const layer1 = document.querySelector('.layer-1');
                    const layer2 = document.querySelector('.layer-2');
                    setupLayer(layer1, heroSlides[0]);
                    layer1.classList.add('active');
                    if (heroSlides.length > 1) setupLayer(layer2, heroSlides[1]);
                    currentSlideIndex = 1 % heroSlides.length;
                    if (slideInterval) clearInterval(slideInterval);
                    slideInterval = setInterval(updateHeroBackground, SLIDE_DURATION_MS); 
                }
            }
        }

        async function showHome(pushState = true) {
            stopPlayer();
            
            window.scrollTo(0, 0);
            
            document.body.classList.remove('viewing-mode');
    document.body.classList.remove('video-ready');
            if (pushState) history.pushState({ view: 'home' }, '', '#home');
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector('.tab:nth-child(1)').classList.add('active');
            document.getElementById('grid').classList.add('hidden');
            const detailView = document.getElementById('detail');
            detailView.classList.add('hidden');
            detailView.classList.remove('visible');
            const home = document.getElementById('home');
            home.innerHTML = ''; 
            await loadHeroSlides(); 
            home.classList.remove('hidden');

            if (continueWatching.length > 0) {
                const groupedWatched = continueWatching.reduce((acc, current) => {
                    if (!current.id || !current.type) return acc;
                    if (!acc[current.id]) acc[current.id] = { id: current.id, type: current.type, entries: [] };
                    acc[current.id].entries.push(current);
                    return acc;
                }, {});

                const itemsToFetch = Object.values(groupedWatched).map(group => {
                    const isTV = group.type === 'tv';
                    let bestEntry = null;
                    if (isTV) bestEntry = group.entries.sort((a, b) => { if (b.season !== a.season) return b.season - a.season; return b.episode - a.episode; })[0];
                    else bestEntry = group.entries.sort((a, b) => b.time - a.time)[0];
                    group.resume_entry = bestEntry;
                    return group;
                });

                const promises = itemsToFetch.map(async itemGroup => {
                    const res = await fetch(`${TMDB_BASE}/${itemGroup.type}/${itemGroup.id}?api_key=${API_KEY}&language=en-US`);
                    if (res.ok) { const itemDetails = await res.json(); itemDetails.type = itemGroup.type; itemDetails.resume_entry = itemGroup.resume_entry; return itemDetails; }
                    return null;
                });
                
                const items = (await Promise.all(promises)).filter(Boolean);
                items.sort((a, b) => b.resume_entry.timestamp - a.resume_entry.timestamp);

                if (items.length > 0) renderCarousel('continue watching', items, home, true);
            }

            await loadSimilarShows(home);
            const endpoints = [
                { title: 'trending now', url: '/trending/all/week' },
                { title: 'popular movies', url: '/movie/popular' },
                { title: 'popular tv shows', url: '/tv/popular' },
                { title: 'top rated movies', url: '/movie/top_rated' },
                { title: 'top rated tv shows', url: '/tv/top_rated' },
                { title: 'in theaters', url: '/movie/now_playing' },
                { title: 'upcoming movies', url: '/movie/upcoming' },
                { title: 'airing today', url: '/tv/airing_today' }
            ];

            for (const ep of endpoints) {
                const res = await fetch(`${TMDB_BASE}${ep.url}?api_key=${API_KEY}&language=en-US`);
                if (res.ok) { const data = await res.json(); const resultsWithPosters = data.results.filter(item => item.poster_path).slice(0, 20); renderCarousel(ep.title, resultsWithPosters, home); }
            }
            setTimeout(() => { const firstItem = document.querySelector('.carousel-item'); if (firstItem) focusItem(firstItem); else document.querySelector('.tab.active')?.focus(); }, 300);
        }

       async function showDetail(id, type, resumeSeason = 1, resumeEpisode = 1, pushState = true) {
    stopPlayer();
    
    // 1. VIEWING MODE SETUP
    document.body.classList.add('viewing-mode');
    window.scrollTo(0, 0); 
    populateServerList();

    // 2. GHOST LOADER
    const loader = document.getElementById('smartLoader');
    if (loader) {
        loader.classList.add('active');
        loader.style.opacity = '1';
        fetch(`${TMDB_BASE}/${type}/${id}?api_key=${API_KEY}`)
            .then(res => res.json())
            .then(data => {
                if(data.backdrop_path) document.getElementById('loaderBackdrop').src = IMG_BASE + data.backdrop_path;
            });
    }

    if (pushState) history.pushState({ view: 'detail', id, type, season: resumeSeason, episode: resumeEpisode }, '', `#${type}/${id}`);
    
    try {
        const [itemRes, creditsRes] = await Promise.all([
            fetch(`${TMDB_BASE}/${type}/${id}?api_key=${API_KEY}&language=en-US`),
            fetch(`${TMDB_BASE}/${type}/${id}/credits?api_key=${API_KEY}&language=en-US`)
        ]);
        
        const item = itemRes.ok ? await itemRes.json() : {};
        const credits = creditsRes.ok ? await creditsRes.json() : { cast: [] };

        currentId = id;
        currentType = type;
        currentSeriesRuntime = item.episode_run_time?.[0] || item.runtime || 3600;
        currentVideoTotalRuntime = currentSeriesRuntime; 

        document.getElementById('title').textContent = item.title || item.name;
        document.getElementById('overview').textContent = item.overview || 'no overview available.';
        document.getElementById('detailPoster').src = IMG_BASE + (item.poster_path || item.backdrop_path || '');
        
        const rating = item.vote_average ? `${item.vote_average.toFixed(1)}/10` : '--';
        const runtime = type === 'movie' ? `${item.runtime || '--'} min` : `${item.episode_run_time?.[0] || '--'} min`;
        document.getElementById('rating').textContent = `rating: ${rating}`;
        document.getElementById('runtime').textContent = `runtime: ${runtime}`;
        renderCast(credits.cast);

        // --- THE UI SPLITTER ---
        const box = document.getElementById('unifiedControls');
        const tvMode = document.getElementById('tvInputs');
        const sportMode = document.getElementById('sportInputs');

        if (type === 'movie') {
            currentSeason = 1; currentEpisode = 1;
            
            // MOVIE MODE: Hide the entire box (Clean Look)
            box.classList.add('hidden');
            document.getElementById('episodeInfo').classList.add('hidden');
            
            startStreaming();
        } else {
            // TV MODE: Show Box, Switch to TV Inputs
            box.classList.remove('hidden');
            tvMode.style.display = 'flex';     // Show Season/Ep
            sportMode.style.display = 'none';  // Hide Server Select
            
            document.getElementById('episodeInfo').classList.remove('hidden');
            
            // ... existing season loading logic ...
            let initialSeason = resumeSeason;
            let initialEpisode = resumeEpisode;
            const validSeasons = item.seasons ? item.seasons.filter(s => s.season_number > 0) : [];
            
            if (validSeasons.length === 0) { 
                setStatus("no seasons found"); 
            } else {
                if (!validSeasons.some(s => s.season_number == initialSeason)) {
                    initialSeason = validSeasons[0].season_number;
                    initialEpisode = 1;
                }
                renderSeasons(validSeasons, initialSeason, initialEpisode);
            }
        }

        // VISIBILITY
        document.getElementById('home').classList.add('hidden');
        document.getElementById('grid').classList.add('hidden');
        document.getElementById('detail').classList.remove('hidden'); 
        document.getElementById('detail').classList.add('visible');
        
        setTimeout(() => {
            const playBtn = document.getElementById('hudPlayPause');
            if(playBtn) { playBtn.focus(); highlightElement(playBtn); wakeUpHUD(); }
        }, 500);

    } catch (err) {
        console.error("Critical Detail Load Error:", err);
        if (loader) loader.classList.remove('active');
    }
}

// 6. GHOST LOADER FADE LISTENER
window.ipcRenderer.on('stream-ready-to-fade', () => {
    // 1. RELEASE THE LOCK
    kickstartLock = false; 
    console.log(" Kickstart Lock Released (Stream Ready)");

    const loader = document.getElementById('smartLoader');
    if (loader) {
        loader.style.opacity = '0';
        setTimeout(() => {
            loader.classList.remove('active');
            document.body.classList.add('video-ready');
        }, 300);
    }
});


        function updateEpisodeInfo(data) {
            document.getElementById('episodeTitle').textContent = data.name || 'untitled episode';
            document.getElementById('episodeDesc').textContent = data.overview || 'no episode description available.';
            const episodeRuntime = data.runtime || currentSeriesRuntime;
            document.getElementById('duration').textContent = episodeRuntime ? `${episodeRuntime} min` : 'n/a';
            currentVideoTotalRuntime = (episodeRuntime * 60) || 3600; 
        }

        function renderSeasons(seasons, initialSeason = 1, initialEpisode = 1) {
            const seasonSelect = document.getElementById('seasonSelect');
            seasonSelect.innerHTML = seasons.map(s => `<option value="${s.season_number}">${s.name}</option>`).join('');
            
            seasonSelect.onchange = () => { 
                // 1. Force Scroll to Top (Ensures HUD logic works)
                window.scrollTo({ top: 0, behavior: 'smooth' });
                
                currentSeason = parseInt(seasonSelect.value); 
                loadEpisodes(currentSeason, 1); 
            };
            
            currentSeason = initialSeason;
            seasonSelect.value = currentSeason;
            loadEpisodes(currentSeason, initialEpisode);
        }

        async function loadEpisodes(season, initialEpisode = 1) {
            const episodeSelect = document.getElementById('episodeSelect');
            const res = await fetch(`${TMDB_BASE}/tv/${currentId}/season/${season}?api_key=${API_KEY}&language=en-US`);
            const data = await res.json();
            const validEpisodes = data.episodes ? data.episodes.filter(e => e.name) : [];
            if (validEpisodes.length === 0) { episodeSelect.innerHTML = `<option value="1">no episodes found</option>`; setStatus("no episodes found for this season "); return; }
            episodeSelect.innerHTML = validEpisodes.map(e => `<option value="${e.episode_number}">S${season}E${e.episode_number}: ${e.name || 'untitled'}</option>`).join('');
            episodeSelect.onchange = () => {
                currentEpisode = parseInt(episodeSelect.value);
                const epData = validEpisodes.find(e => e.episode_number == currentEpisode);
                updateEpisodeInfo(epData);
                startStreaming();
            };
            currentEpisode = initialEpisode;
            if (!validEpisodes.some(e => e.episode_number == currentEpisode)) currentEpisode = validEpisodes.length > 0 ? validEpisodes[0].episode_number : 1;
            episodeSelect.value = currentEpisode;
            const epData = validEpisodes.find(e => e.episode_number == currentEpisode) || validEpisodes[0] || { name: 'Episode N/A', overview: 'No information available for this episode.', runtime: currentSeriesRuntime };
            updateEpisodeInfo(epData);
            startStreaming();
        }
        
        function openSettings() {
            document.getElementById('logoMenu').classList.remove('visible');
            const modal = document.getElementById('settingsModal');
            modal.classList.add('visible');
            document.querySelector('.main-content').classList.add('blur-background');
            document.getElementById('qualityPref').value = qualityPref;
            document.getElementById('aiUpscalingToggle').checked = aiUpscalingEnabled;
            document.getElementById('perfModeToggle').checked = performanceMode;
            document.getElementById('autoplayToggle').checked = autoplayEnabled;
            if(performanceMode) document.body.classList.add('performance-mode');
            document.getElementById('autoplayToggle').addEventListener('change', (e) => {
                autoplayEnabled = e.target.checked;
                localStorage.setItem('ot_autoplay', autoplayEnabled);
            });
            setTimeout(() => { const closeBtn = modal.querySelector('.close'); if(closeBtn) closeBtn.focus(); }, 100);
        }

        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            modal.classList.remove('visible');
            document.querySelector('.main-content').classList.remove('blur-background');
            setTimeout(() => {
                const newQualityPref = document.getElementById('qualityPref').value;
                if (newQualityPref !== qualityPref) { qualityPref = newQualityPref; localStorage.setItem('qualityPref', qualityPref); if (currentId) startStreaming(); }
                const newAiUpscalingEnabled = document.getElementById('aiUpscalingToggle').checked;
                if (newAiUpscalingEnabled !== aiUpscalingEnabled) { aiUpscalingEnabled = newAiUpscalingEnabled; localStorage.setItem('aiUpscalingEnabled', aiUpscalingEnabled); if (currentId) updatePlayerQuality(); }
            }, 400); 
        }

        async function switchTab(type) {
            currentView = type;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[data-view="${type}"]`).classList.add('active');
            document.getElementById('home').classList.add('hidden');
            document.getElementById('detail').classList.add('hidden');
            const grid = document.getElementById('grid');
            grid.classList.remove('hidden');
            grid.innerHTML = ''; 
            const res = await fetch(`${TMDB_BASE}/${type}/popular?api_key=${API_KEY}`);
            const data = await res.json();
            const fragment = document.createDocumentFragment();
            data.results.forEach(item => {
                if(!item.poster_path) return;
                const div = document.createElement('div');
                div.className = 'grid-item';
                div.tabIndex = 0;
                div.innerHTML = `<img src="${IMG_BASE}${item.poster_path}" loading="lazy" decoding="async"><div class="grid-item-title">${item.title || item.name}</div>`;
                div.onclick = () => showDetail(item.id, type);
                observer.observe(div);
                fragment.appendChild(div);
            });
            grid.appendChild(fragment);
            setTimeout(() => { const first = grid.querySelector('.grid-item'); if(first) focusItem(first); }, 50);
        }

        const STREAMED_API = "https://streamed.pk/api";

// 1. INTERCEPT TABS
const originalSwitchTab = switchTab;
switchTab = function(type) {
    if (type === 'sports') {
        currentView = 'sports';
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelector(`.tab[data-view="sports"]`).classList.add('active');
        document.getElementById('home').classList.add('hidden');
        document.getElementById('grid').classList.add('hidden');
        document.getElementById('detail').classList.add('hidden');
        
        loadSportsTab();
        return;
    }
    return originalSwitchTab(type);
};




// --- RENDERER (CSS FIX FOR STRETCHING) ---
function renderSportsCarousel(title, items, container) {
    const row = document.createElement('div');
    row.className = 'row';
    row.innerHTML = `<div class="row-title">${title}</div>`;
    const carouselContainer = document.createElement('div');
    carouselContainer.className = 'carousel-container';
    const carousel = document.createElement('div');
    carousel.className = 'carousel';
    enableMouseEdgeScrolling(carousel);
    
    const fragment = document.createDocumentFragment();
    items.forEach((item, i) => {
        const div = document.createElement('div');
        div.className = 'carousel-item';
        div.tabIndex = 0;
        div.style.transitionDelay = `${i * 50}ms`; 
        
        // --- THE ANTI-STRETCH CSS ---
        // 1. If High-Res (is_generic_logo = false): Use 'cover' to fill the card beautifully.
        // 2. If Generic (is_generic_logo = true): Use 'contain' to fit the logo, 
        //    but set a dark background so it looks like a card, not a PNG floating in space.
        
        const imgStyle = item.is_generic_logo 
            ? 'object-fit: contain; padding: 30px; background: linear-gradient(to bottom, #1a1a1a, #000);' 
            : 'object-fit: cover;';

        div.innerHTML = `
            <img src="${item.poster_path}" style="width:100%; height:100%; ${imgStyle}" loading="lazy" decoding="async">
            <div class="carousel-item-title">${item.title}</div>
        `;
        
        div.onclick = () => playSportStream(item);
        fragment.appendChild(div);
    });
    
    carousel.appendChild(fragment);
    carouselContainer.appendChild(carousel);
    row.appendChild(carouselContainer);
    requestAnimationFrame(() => { container.appendChild(row); observer.observe(row); });
}

// 2. MAIN SPORTS LOADER
// 2. MAIN SPORTS LOADER
// --- SPORTS ENGINE (Updated for Streamed.pk) ---

async function loadSportsTab() {
    const home = document.getElementById('home');
    home.innerHTML = '';
    home.classList.remove('hidden');

    // 1. LIVE NOW (Updated Domain)
    await loadSportsCarousel("live now", `https://streamed.pk/api/matches/live`, home);

    // 2. FIGHTING (Updated Domain)
    await loadFightingCarousel(home);

    // 3. BASED ON YOUR VIEWING
    loadRecommendationCarousel(home);

    // 4. LEAGUES (Updated Domain)
    const categories = [
        { title: "nba", endpoint: "basketball" },
        { title: "nfl", endpoint: "american-football" },
        { title: "mlb", endpoint: "baseball" },
        { title: "nhl", endpoint: "hockey" },
        { title: "soccer", endpoint: "football" },
        { title: "formula 1", endpoint: "f1" }
    ];

    for (const cat of categories) {
        await loadSportsCarousel(cat.title, `https://streamed.pk/api/matches/${cat.endpoint}`, home);
    }
}

async function loadFightingCarousel(container) {
    try {
        const [mmaRes, boxingRes] = await Promise.all([
            fetch('https://streamed.pk/api/matches/mma'),
            fetch('https://streamed.pk/api/matches/boxing')
        ]);

        const mma = mmaRes.ok ? await mmaRes.json() : [];
        const boxing = boxingRes.ok ? await boxingRes.json() : [];
        
        const allFights = [...mma, ...boxing].sort((a, b) => new Date(a.date) - new Date(b.date));

        if (allFights.length > 0) {
            const items = allFights.map(m => processSportItem(m));
            renderSportsCarousel("fighting (ufc / mma / boxing)", items, container);
        }
    } catch (e) { console.log("Fighting load error:", e); }
}

function processSportItem(m) {
    // 1. Fallback Posters (TheSportsDB)
    const leaguePosters = {
        'UFC': 'https://www.thesportsdb.com/images/media/league/poster/44v30e1549147572.jpg',
        'MMA': 'https://www.thesportsdb.com/images/media/league/poster/44v30e1549147572.jpg',
        'Boxing': 'https://www.thesportsdb.com/images/media/league/poster/98505a1595966406.jpg',
        'NBA': 'https://www.thesportsdb.com/images/media/league/poster/4b78c41624653896.jpg',
        'NFL': 'https://www.thesportsdb.com/images/media/league/poster/80w25p1566426458.jpg',
        'NHL': 'https://www.thesportsdb.com/images/media/league/poster/st81m11599337373.jpg',
        'MLB': 'https://www.thesportsdb.com/images/media/league/poster/cm63491565985059.jpg',
        'Formula 1': 'https://www.thesportsdb.com/images/media/league/poster/78720e1564771238.jpg',
        'Premier League': 'https://www.thesportsdb.com/images/media/league/poster/wesr871626265744.jpg',
        'B1G': 'https://www.thesportsdb.com/images/media/league/poster/6f753e1554664870.jpg',
        'NCAA': 'https://www.thesportsdb.com/images/media/league/poster/6f753e1554664870.jpg'
    };

    // 2. Domain Update for Images
    let posterUrl = m.poster ? `https://streamed.pk${m.poster}` : null;
    let isGeneric = true; 

    // 3. Smart Fallback Logic
    for (const [key, url] of Object.entries(leaguePosters)) {
        if (m.title.includes(key) || m.category.toUpperCase().includes(key) || (m.league && m.league.includes(key))) {
            if (!posterUrl || posterUrl.includes('logo.png')) {
                posterUrl = url;
                isGeneric = false;
            }
        }
    }

    if (!posterUrl) {
        posterUrl = "https://www.thesportsdb.com/images/media/league/poster/44v30e1549147572.jpg"; 
    }

    if (posterUrl.includes('thesportsdb.com')) {
        isGeneric = false;
    }

    return {
        id: m.id,
        title: m.title.toLowerCase(),
        poster_path: posterUrl,
        is_generic_logo: isGeneric, 
        overview: `live event: ${m.title} - ${new Date(m.date).toLocaleString()}`,
        is_sport: true,
        sport_category: m.category
    };
}

async function loadSportsCarousel(title, url, container) {
    try {
        const res = await fetch(url);
        if (!res.ok) return;
        const matches = await res.json();
        
        if (!matches || matches.length === 0) return;

        const items = matches.map(m => processSportItem(m));
        renderSportsCarousel(title, items, container);
    } catch (e) { console.log(`Skipping ${title}: ${e.message}`); }
}

async function loadFightingCarousel(container) {
    try {
        const [mmaRes, boxingRes] = await Promise.all([
            fetch('https://streamed.su/api/matches/mma'),
            fetch('https://streamed.su/api/matches/boxing')
        ]);

        const mma = mmaRes.ok ? await mmaRes.json() : [];
        const boxing = boxingRes.ok ? await boxingRes.json() : [];
        
        // Combine and Sort by Date
        const allFights = [...mma, ...boxing].sort((a, b) => new Date(a.date) - new Date(b.date));

        if (allFights.length > 0) {
            // Process images using the new "Anti-Stretch" processor
            const items = allFights.map(m => processSportItem(m));
            renderSportsCarousel("fighting (ufc / mma / boxing)", items, container);
        }
    } catch (e) { console.log("Fighting load error:", e); }
}

// SMART IMAGE FETCHER (TheSportsDB)
// Tries to find a vertical poster. If match art is missing, grabs the high-res League Poster.
async function getBetterSportImage(match) {
    // 1. Default to the source image
    let bestImage = `https://streamed.su${match.poster || '/images/logo.png'}`;
    
    // 2. Map Streamed categories to TheSportsDB League names
    const leagueMap = {
        'UFC': 'UFC',
        'NBA': 'NBA',
        'NFL': 'NFL',
        'NHL': 'NHL',
        'MLB': 'MLB',
        'Formula 1': 'Formula 1',
        'Premier League': 'English Premier League'
    };

    // Quick lookup for high-res fallback posters (Vertical 2:3)
    // We use these if we can't find a specific match image, so it looks like a movie library.
    const fallbackPosters = {
        'UFC': 'https://www.thesportsdb.com/images/media/league/poster/44v30e1549147572.jpg',
        'NBA': 'https://www.thesportsdb.com/images/media/league/poster/4b78c41624653896.jpg',
        'NFL': 'https://www.thesportsdb.com/images/media/league/poster/80w25p1566426458.jpg',
        'NHL': 'https://www.thesportsdb.com/images/media/league/poster/st81m11599337373.jpg',
        'MLB': 'https://www.thesportsdb.com/images/media/league/poster/cm63491565985059.jpg',
        'Formula 1': 'https://www.thesportsdb.com/images/media/league/poster/78720e1564771238.jpg'
    };

    // If the match title contains a known league, upgrade the poster
    for (const [key, url] of Object.entries(fallbackPosters)) {
        if (match.title.includes(key) || match.category.toUpperCase().includes(key)) {
            // Only replace if the original is the generic logo
            if(bestImage.includes('logo.png') || !match.poster) {
                bestImage = url;
            }
        }
    }

    return bestImage;
}



// 4. RECOMMENDATION ENGINE
function loadRecommendationCarousel(container) {
    // Find the last watched sport category
    const lastSport = continueWatching.find(i => i.type === 'sport');
    
    if (lastSport && lastSport.sport_category) {
        const cat = lastSport.sport_category.toUpperCase();
        loadSportsCarousel(`BECAUSE YOU WATCHED ${cat}`, `${STREAMED_API}/matches/${lastSport.sport_category}`, container);
    }
}

// 5. RENDERER OVERRIDE (Handle full image URLs)
const originalRenderCarousel = renderCarousel;
renderCarousel = function(title, items, container, isResume = false) {
    // If it's a sport, we use a custom renderer or adapt the logic
    if (items.length > 0 && items[0].is_sport) {
        const row = document.createElement('div');
        row.className = 'row';
        row.innerHTML = `<div class="row-title">${title}</div>`;
        const carouselContainer = document.createElement('div');
        carouselContainer.className = 'carousel-container';
        const carousel = document.createElement('div');
        carousel.className = 'carousel';
        enableMouseEdgeScrolling(carousel);
        
        const fragment = document.createDocumentFragment();
        items.forEach((item, i) => {
            const div = document.createElement('div');
            div.className = 'carousel-item';
            div.tabIndex = 0;
            div.style.transitionDelay = `${i * 50}ms`; 
            
            // Sports use full URL, not TMDB prefix
            div.innerHTML = `
                <img src="${item.poster_path}" loading="lazy" decoding="async">
                <div class="carousel-item-title">${item.title}</div>
            `;
            
            div.onclick = () => playSportStream(item);
            fragment.appendChild(div);
        });
        
        carousel.appendChild(fragment);
        carouselContainer.appendChild(carousel);
        row.appendChild(carouselContainer);
        requestAnimationFrame(() => { container.appendChild(row); observer.observe(row); });
        return;
    }
    
    // Otherwise use standard renderer
    originalRenderCarousel(title, items, container, isResume);
};

// 6. PLAYER LOGIC
let currentSportStreams = [];

async function playSportStream(item) {
    stopPlayer();
    currentSportStreams = [];

    // 1. Show Detail View
    document.getElementById('home').classList.add('hidden');
    document.getElementById('grid').classList.add('hidden');
    document.getElementById('detail').classList.remove('hidden');
    document.getElementById('detail').classList.add('visible');

    // 2. UNIFIED BOX LOGIC (Switch to Sports Mode)
    const box = document.getElementById('unifiedControls');
    const tvMode = document.getElementById('tvInputs');
    const sportMode = document.getElementById('sportInputs');

    box.classList.remove('hidden');       // Show the main box
    tvMode.style.display = 'none';        // Hide Season/Ep
    sportMode.style.display = 'flex';     // Show Server Select

    // 3. Metadata
    document.getElementById('title').textContent = item.title;
    document.getElementById('overview').textContent = item.overview || "Live Event";
    document.getElementById('detailPoster').src = item.poster_path;
    document.getElementById('rating').textContent = "LIVE";
    document.getElementById('runtime').textContent = "Sports";
    document.getElementById('episodeInfo').classList.add('hidden'); // Ensure Episode text is gone

    // 4. Start Scanner
    const select = document.getElementById('sportSourceSelect');
    select.innerHTML = `<option>Scanning live feeds...</option>`;
    setStatus(`Searching streams for ${item.title}...`, true);
    window.ipcRenderer.send('start-sport-scan', { category: item.sport_category, matchId: item.id });
}

// 7. LISTENERS
window.ipcRenderer.on('sport-stream-found', (e, stream) => {
    const select = document.getElementById('sportSourceSelect');
    
    // If this is the FIRST stream found -> Play Immediately
    if (stream.isFirst) {
        select.innerHTML = ''; // Clear "Scanning..."
        currentSportStreams = [];
        
        const player = document.getElementById('player');
        player.src = stream.streamUrl;
        
        // TRIGGER CINEMATIC MODE
        document.body.classList.add('viewing-mode');
        document.body.classList.add('video-ready');
        startFocusSentinel(); 
        
        setStatus("Signal Acquired!", false);
        setTimeout(hideStatus, 2000);
    }

    // Add to list
    currentSportStreams.push(stream);
    
    const opt = document.createElement('option');
    opt.value = currentSportStreams.length - 1; 
    opt.text = ` ${stream.name}`;
    select.appendChild(opt);

    if (stream.isFirst) select.selectedIndex = 0;
});

window.ipcRenderer.on('sport-error', (e, msg) => {
    if (currentSportStreams.length === 0) setStatus(`Error: ${msg}`, false);
});

function switchSportSource(index) {
    const stream = currentSportStreams[index];
    if (stream) {
        setStatus(`Switching to ${stream.name}...`, true);
        document.getElementById('player').src = stream.streamUrl;
        setTimeout(hideStatus, 1000);
    }
}
        
        const debouncedSearch = debounce(() => { if (document.getElementById('searchInput').value.trim().length > 0) search(true); }, 500); 

        async function search(reset = false) {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) return;
            if (reset) { window.scrollTo(0, 0); currentPage = 1; currentAction = 'search'; currentQuery = query; document.getElementById('grid').innerHTML = ''; }
            const url = `${TMDB_BASE}/search/multi?api_key=${API_KEY}&query=${encodeURIComponent(query)}&language=en-US&page=${currentPage}`;
            const res = await fetch(url);
            const data = await res.json();
            const grid = document.getElementById('grid');
            grid.classList.remove('hidden');
            document.getElementById('home').classList.add('hidden');
            document.getElementById('detail').classList.add('hidden');
            document.getElementById('detail').classList.remove('visible');
            const results = data.results.filter(item => (item.media_type === 'movie' || item.media_type === 'tv') && item.poster_path);
            if (results.length === 0 && currentPage === 1) { grid.innerHTML = '<div style="padding: 40px; text-align: center; font-size: 24px; color: var(--text-secondary);">no results found for this query.</div>'; return; }
            const fragment = document.createDocumentFragment();
            results.forEach((item, i) => {
                const itemType = item.media_type || 'movie';
                const div = document.createElement('div');
                div.className = 'grid-item';
                div.tabIndex = 0;
                div.innerHTML = `<div class="more-options-btn" onclick="showContextMenu(event, ${item.id}, '${itemType}')"></div><img src="${IMG_BASE}${item.poster_path}" loading="lazy" decoding="async" alt="${item.title || item.name}"><div class="grid-item-title">${item.title || item.name}</div>`;
                div.onclick = () => showDetail(item.id, itemType);
                observer.observe(div);
                fragment.appendChild(div);
            });
            grid.appendChild(fragment);
            if (data.total_pages > currentPage) { setupSentinel(grid); currentPage++; } else removeSentinel();
            if(reset) { setTimeout(() => { const first = grid.querySelector('.grid-item'); if(first) focusItem(first); }, 100); }
        }
        
        async function loadTrending(reset = false) {
            if (reset) { window.scrollTo(0, 0); currentPage = 1; currentAction = 'trending'; document.getElementById('grid').innerHTML = ''; }
            const url = `${TMDB_BASE}/trending/${currentType}/week?api_key=${API_KEY}&language=en-US&page=${currentPage}`;
            const res = await fetch(url);
            const data = await res.json();
            const grid = document.getElementById('grid');
            renderGridItems(data.results.filter(item => item.poster_path), grid);
            if (data.total_pages > currentPage) { setupSentinel(grid); currentPage++; } else removeSentinel();
        }

        function renderGridItems(items, grid) {
            items.forEach((item, i) => {
                const itemType = item.media_type || currentType; 
                const div = document.createElement('div');
                div.className = 'grid-item';
                div.tabIndex = 0; 
                div.style.transitionDelay = `${i * 0.05}s`;
                div.onclick = () => showDetail(item.id, itemType); 
                div.innerHTML = `<img src="${IMG_BASE}${item.poster_path || item.backdrop_path || ''}" alt="${item.title || item.name}"><div class="grid-item-title">${item.title || item.name}</div>`;
                grid.appendChild(div);
                observer.observe(div);
            });
        }

        function setupSentinel(grid) {
            removeSentinel(); 
            const sentinel = document.createElement('div');
            sentinel.id = 'loadMoreSentinel';
            grid.appendChild(sentinel);
            observer.observe(sentinel);
        }

        function removeSentinel() {
            const existingSentinel = document.getElementById('loadMoreSentinel');
            if (existingSentinel) { observer.unobserve(existingSentinel); existingSentinel.remove(); }
        }

        function loadMoreContent() {
            removeSentinel(); 
            if (currentAction === 'trending') loadTrending(false); 
            else if (currentAction === 'search') search(false);
        }
        
        let rowMemory = new Map(); 
        document.addEventListener('keydown', (e) => {
            if (document.body.classList.contains('viewing-mode')) return;
            if (isMenuOpen) {
                e.preventDefault();
                e.stopPropagation();
                const items = Array.from(document.querySelectorAll('.context-menu-item'));
                const visibleItems = items.filter(item => item.style.display !== 'none');
                if (e.key === 'ArrowDown') { menuFocusIndex++; if (menuFocusIndex >= visibleItems.length) menuFocusIndex = 0; updateMenuHighlight(); } 
                else if (e.key === 'ArrowUp') { menuFocusIndex--; if (menuFocusIndex < 0) menuFocusIndex = visibleItems.length - 1; updateMenuHighlight(); } 
                else if (e.key === 'Enter') { if (ignoreEnterUntilRelease) return; if (visibleItems[menuFocusIndex]) visibleItems[menuFocusIndex].click(); }
                else if (e.key === 'Escape' || e.key === 'Backspace') { hideContextMenu(); }
                return;
            }

            const isKeyboardOpen = document.getElementById('keyboardModal').classList.contains('visible');
            const isSettingsOpen = document.getElementById('settingsModal').classList.contains('visible');
            const isLogoMenuOpen = document.getElementById('logoMenu').classList.contains('visible');
            const isProfileGateOpen = document.getElementById('profileGate').classList.contains('visible');
            const isEditProfileOpen = document.getElementById('editProfileModal').classList.contains('visible');
            
            if (isKeyboardOpen) { handleKeyboardModalNav(e); return; }
            if (isEditProfileOpen) return;

            if (isProfileGateOpen) {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                    const cards = Array.from(document.querySelectorAll('.profile-card, .profile-manage-btn'));
                    const current = document.activeElement;
                    const index = cards.indexOf(current);
                    if(index === -1) { if(cards.length > 0) cards[0].focus(); return; }
                    if (e.key === 'ArrowRight' && index < cards.length - 1) cards[index+1].focus();
                    else if (e.key === 'ArrowLeft' && index > 0) cards[index-1].focus();
                    else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                        if (current.id === 'manageBtn') { if(cards.length > 0) cards[0].focus(); }
                        else { const btn = document.getElementById('manageBtn'); if(btn) btn.focus(); }
                    }
                }
                if (e.key === 'Enter') document.activeElement.click();
                return; 
            }

            if (isSettingsOpen) {
                e.preventDefault(); e.stopPropagation();
                if (e.key === 'Escape' || e.key === 'Backspace') { closeSettings(); return; }
                handleModalNav(e, 'settingsModal');
                return;
            }

            if (isLogoMenuOpen) {
                e.preventDefault();
                if (e.key === 'Escape' || e.key === 'Backspace' || e.key === 'ArrowLeft') { toggleLogoMenu(); return; }
                const items = Array.from(document.querySelectorAll('.logo-menu-item'));
                const current = document.activeElement;
                const idx = items.indexOf(current);
                if (e.key === 'ArrowDown') { if (idx < items.length - 1) items[idx + 1].focus(); }
                else if (e.key === 'ArrowUp') { if (idx === 0) toggleLogoMenu(); else if (idx > 0) items[idx - 1].focus(); }
                else if (e.key === 'Enter') current.click();
                return;
            }
            
            if (e.key === 'Backspace' || e.key === 'Escape') {
                e.preventDefault();
                if (document.getElementById('detail').classList.contains('visible')) showHome();
                else document.getElementById('searchInput').focus();
                return;
            }

            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                if (document.getElementById('detail').classList.contains('visible')) { handleDetailNav(e.key); return; }
                handleGeneralNav(e.key); 
            } 
            else if (e.key === 'Enter') {
                const active = document.activeElement;
                if (active.tagName === 'SELECT') return; 
                if (active.type === 'checkbox') { e.preventDefault(); active.checked = !active.checked; return; }
                if (active.classList.contains('fullscreen-btn')) { e.preventDefault(); toggleFullscreen(); return; }
                if (active.classList.contains('carousel-item') || active.classList.contains('grid-item')) {
                    e.preventDefault(); 
                    e.stopPropagation(); 
                    if (!isLongPressActive) {
                        isLongPressActive = true;
                        longPressTriggered = false;
                        active.classList.add('shaking');
                        longPressTimer = setTimeout(() => {
                            longPressTriggered = true;
                            ignoreEnterUntilRelease = true; 
                            active.classList.remove('shaking');
                            const dotBtn = active.querySelector('.more-options-btn');
                            if (dotBtn) {
                                const onClickAttr = dotBtn.getAttribute('onclick');
                                const match = onClickAttr.match(/showContextMenu\(event,\s*(\d+),\s*'([a-zA-Z0-9]+)'\)/);
                                if (match) {
                                    const id = match[1];
                                    const type = match[2];
                                    const rect = active.getBoundingClientRect();
                                    const fakeEvent = {
                                        preventDefault: () => {},
                                        stopPropagation: () => {},
                                        pageX: rect.right + window.scrollX - 40,
                                        pageY: rect.top + window.scrollY + 20,
                                        clientX: rect.right - 40, 
                                        clientY: rect.top + 20
                                    };
                                    showContextMenu(fakeEvent, id, type);
                                }
                            }
                        }, 1000); 
                    }
                    return;
                }
                e.preventDefault(); e.stopPropagation(); active.click();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                ignoreEnterUntilRelease = false; 
                const active = document.activeElement;
                if (isLongPressActive) {
                    clearTimeout(longPressTimer);
                    active.classList.remove('shaking');
                    isLongPressActive = false;
                    if (!longPressTriggered) active.click();
                }
            }
        });

        function handleModalNav(e, modalId) {
            const modal = document.getElementById(modalId);
            const focusables = Array.from(modal.querySelectorAll('.close, select, input, button, [tabindex="0"]'));
            const current = document.activeElement;
            const index = focusables.indexOf(current);
            if (current.tagName === 'SELECT') {
                if (e.key === 'Enter') { try { current.showPicker(); } catch (err) {} return; }
                if (e.key === 'ArrowRight') { if (current.selectedIndex < current.options.length - 1) { current.selectedIndex++; current.dispatchEvent(new Event('change')); } return; }
                if (e.key === 'ArrowLeft') { if (current.selectedIndex > 0) { current.selectedIndex--; current.dispatchEvent(new Event('change')); } return; }
            }
            if (e.key === 'ArrowDown') { e.preventDefault(); if (index < focusables.length - 1) focusables[index + 1].focus(); else focusables[0].focus(); } 
            else if (e.key === 'ArrowUp') { e.preventDefault(); if (index > 0) focusables[index - 1].focus(); else focusables[focusables.length - 1].focus(); }
            else if (e.key === 'Enter') { if (current.type === 'checkbox') { e.preventDefault(); current.checked = !current.checked; } else if (current.classList.contains('close')) { e.preventDefault(); current.click(); } }
        }

        function handleDetailNav(direction) {
            const current = document.activeElement;
            if (current.classList.contains('tab')) {
                if (direction === 'ArrowDown') {
                    if (!document.getElementById('unifiedControls').classList.contains('hidden')) document.getElementById('seasonSelect').focus();
                    else { const firstCast = document.querySelector('.cast-item'); if (firstCast) firstCast.focus(); }
                    return;
                }
                handleHeaderNav(direction, current);
                return;
            }
            if (current.closest('.seasons')) {
                if (direction === 'ArrowUp') { window.scrollTo({ top: 0, behavior: 'smooth' }); document.querySelector('.tab.active').focus(); return; }
                if (direction === 'ArrowDown') { const firstCast = document.querySelector('.cast-item'); if (firstCast) { firstCast.focus(); firstCast.scrollIntoView({behavior: 'smooth', block: 'center'}); } return; }
                const controls = Array.from(document.querySelectorAll('.seasons select, .fullscreen-btn'));
                const idx = controls.indexOf(current);
                if (direction === 'ArrowRight' && idx < controls.length - 1) controls[idx+1].focus();
                if (direction === 'ArrowLeft' && idx > 0) controls[idx-1].focus();
                return;
            }
            if (current.classList.contains('cast-item')) {
                if (direction === 'ArrowUp') { if (!document.getElementById('unifiedControls').classList.contains('hidden')) document.getElementById('seasonSelect').focus(); else { window.scrollTo({ top: 0, behavior: 'smooth' }); document.querySelector('.tab.active').focus(); } return; }
                if (direction === 'ArrowRight' && current.nextElementSibling) current.nextElementSibling.focus();
                if (direction === 'ArrowLeft' && current.previousElementSibling) current.previousElementSibling.focus();
                return;
            }
        }

        function handleGeneralNav(direction) {
            const current = document.activeElement;
            const navRows = getNavigableRows();
            const currentRow = navRows.find(r => r.contains(current));
            const currentIndex = navRows.indexOf(currentRow);
            if (direction === 'ArrowLeft' || direction === 'ArrowRight') {
                if (currentRow && currentRow.tagName === 'HEADER') { handleHeaderNav(direction, current); return; }
                if (current.classList.contains('carousel-item')) {
                    const parent = current.parentElement;
                    const items = Array.from(parent.children).filter(c => c.classList.contains('carousel-item'));
                    const idx = items.indexOf(current);
                    if (direction === 'ArrowRight' && idx < items.length - 1) focusItem(items[idx + 1]);
                    if (direction === 'ArrowLeft' && idx > 0) focusItem(items[idx - 1]);
                    return;
                }
                if (current.classList.contains('grid-item')) {
                     const grid = document.getElementById('grid');
                     const items = Array.from(grid.querySelectorAll('.grid-item'));
                     const idx = items.indexOf(current);
                     if (direction === 'ArrowRight' && idx < items.length - 1) focusItem(items[idx + 1]);
                     if (direction === 'ArrowLeft' && idx > 0) focusItem(items[idx - 1]);
                     return;
                }
            }
            if (direction === 'ArrowUp' || direction === 'ArrowDown') {
                if (current.classList.contains('grid-item')) {
                    const grid = document.getElementById('grid');
                    const items = Array.from(grid.querySelectorAll('.grid-item'));
                    const idx = items.indexOf(current);
                    const cols = 6; 
                    if (direction === 'ArrowDown') { if (idx + cols < items.length) focusItem(items[idx + cols]); } 
                    else { if (idx - cols >= 0) focusItem(items[idx - cols]); else document.querySelector('.tab.active').focus(); }
                    return;
                }
                if (currentIndex === -1) { document.querySelector('.tab.active').focus(); return; }
                let targetIndex = direction === 'ArrowDown' ? currentIndex + 1 : currentIndex - 1;
                if (targetIndex < 0 || targetIndex >= navRows.length) return;
                const targetRow = navRows[targetIndex];
                if (targetRow.tagName === 'HEADER') { document.querySelector('.tab.active').focus(); }
                else if (targetRow.classList.contains('row')) {
                    const items = Array.from(targetRow.querySelectorAll('.carousel-item'));
                    if (items.length === 0) return;
                    if (direction === 'ArrowDown') focusItem(items[0]);
                    else { const saved = rowMemory.get(targetRow) || 0; focusItem(items[Math.min(saved, items.length - 1)]); }
                }
                else if (targetRow.id === 'grid') { const items = targetRow.querySelectorAll('.grid-item'); if(items.length > 0) focusItem(items[0]); }
                if (currentRow && current.classList.contains('carousel-item')) { const items = Array.from(currentRow.querySelectorAll('.carousel-item')); rowMemory.set(currentRow, items.indexOf(current)); }
            }
        }

        function handleHeaderNav(direction, current) {
            if (direction === 'ArrowLeft') {
                if (current.classList.contains('tab')) { if (current.previousElementSibling) current.previousElementSibling.focus(); else document.querySelector('.logo').focus(); return; }
                if (current.id === 'searchInput') { const tabs = document.querySelectorAll('.tab'); tabs[tabs.length - 1].focus(); return; }
            }
            if (direction === 'ArrowRight') {
                if (current.classList.contains('logo')) { document.querySelector('.tab').focus(); return; }
                if (current.classList.contains('tab')) { if (current.nextElementSibling) current.nextElementSibling.focus(); else document.getElementById('searchInput').focus(); return; }
            }
        }

        function getNavigableRows() {
            const rows = [];
            const header = document.querySelector('header');
            if (header) rows.push(header);
            const visibleHomeRows = Array.from(document.querySelectorAll('#home:not(.hidden) .row'));
            visibleHomeRows.forEach(r => rows.push(r));
            const grid = document.getElementById('grid');
            if (grid && !grid.classList.contains('hidden')) rows.push(grid);
            return rows;
        }

        function focusItem(el) {
            if (!el) return;
            el.focus({ preventScroll: true }); 
            const row = el.closest('.row') || el.closest('.grid-item') || el;
            const rowRect = row.getBoundingClientRect();
            const absoluteRowTop = rowRect.top + window.scrollY;
            window.scrollTo({ top: absoluteRowTop - (window.innerHeight / 2) + (rowRect.height / 2), behavior: 'smooth' });
            if (el.classList.contains('carousel-item')) {
                const container = el.parentElement; 
                const containerRect = container.getBoundingClientRect();
                const itemRect = el.getBoundingClientRect();
                if (itemRect.right > containerRect.right) container.scrollLeft += (itemRect.right - containerRect.right) + 40;
                if (itemRect.left < containerRect.left) container.scrollLeft -= (containerRect.left - itemRect.left) + 40;
            }
        }

        function handleKeyboardModalNav(e) {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.key)) e.preventDefault(); 
            const keys = Array.from(document.querySelectorAll('.hg-button'));
            const closeBtn = document.querySelector('#keyboardModal .close');
            const current = document.activeElement;
            if (current === closeBtn) {
                if (e.key === 'Enter') { e.preventDefault(); e.stopPropagation(); current.click(); } 
                else if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') { const targetKey = keys[9] || keys[0]; targetKey.focus(); }
                return;
            }
            if (e.key.length === 1 && /[a-z0-9 ]/i.test(e.key)) {
                 e.preventDefault();
                 const currentInput = keyboard.getInput();
                 const newVal = currentInput + e.key;
                 keyboard.setInput(newVal);
                 onChange(newVal);
                 const keyBtn = document.querySelector(`.hg-button[data-skbtn="${e.key.toLowerCase()}"]`);
                 if (keyBtn) { keyBtn.classList.add('hg-activeButton'); setTimeout(() => keyBtn.classList.remove('hg-activeButton'), 150); }
                 return;
            }
            if (e.key === 'Backspace') {
                 e.preventDefault();
                 const currentInput = document.querySelector("#keyboardInputDisplay").value;
                 const newVal = currentInput.slice(0, -1);
                 keyboard.setInput(newVal);
                 onChange(newVal);
                 return;
            }
            const index = keys.indexOf(current);
            if (index === -1) { if (keys[0]) keys[0].focus(); return; }
            if (e.key === 'ArrowRight' && index < keys.length - 1) keys[index + 1].focus();
            else if (e.key === 'ArrowLeft' && index > 0) keys[index - 1].focus();
            else if (e.key === 'ArrowDown') { const targetIndex = Math.min(index + 10, keys.length - 1); keys[targetIndex].focus(); }
            else if (e.key === 'ArrowUp') { if (index <= 10) closeBtn.focus(); else keys[Math.max(index - 10, 0)].focus(); }
            else if (e.key === 'Enter') { 
                 e.preventDefault(); 
                 const keyVal = current.getAttribute('data-skbtn');
                 if (keyVal === '{enter}') performSearchFromKeyboard();
                 else if (keyVal === '{bksp}') { const currentInput = document.querySelector("#keyboardInputDisplay").value; const newVal = currentInput.slice(0, -1); keyboard.setInput(newVal); onChange(newVal); } 
                 else if (keyVal === '{space}') { const currentInput = keyboard.getInput(); const newVal = currentInput + " "; keyboard.setInput(newVal); onChange(newVal); } 
                 else { const currentInput = keyboard.getInput(); const newVal = currentInput + keyVal; keyboard.setInput(newVal); onChange(newVal); }
            }
        }

        function enableMouseEdgeScrolling(element) {
            let active = false; let direction = 0; let speed = 0; const MAX_SPEED = 7; const ZONE_SIZE = 0.35; 
            const scrollStep = () => { if (!active) return; element.scrollLeft += speed * direction; requestAnimationFrame(scrollStep); };
            element.addEventListener('mousemove', (e) => {
                const rect = element.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const width = rect.width;
                const threshold = width * ZONE_SIZE;
                if (mouseX > width - threshold) { direction = 1; const intensity = (mouseX - (width - threshold)) / threshold; speed = MAX_SPEED * intensity; if (!active) { active = true; element.style.scrollBehavior = 'auto'; requestAnimationFrame(scrollStep); } } 
                else if (mouseX < threshold) { direction = -1; const intensity = (threshold - mouseX) / threshold; speed = MAX_SPEED * intensity; if (!active) { active = true; element.style.scrollBehavior = 'auto'; requestAnimationFrame(scrollStep); } } 
                else { active = false; element.style.scrollBehavior = 'smooth'; }
            });
            element.addEventListener('mouseleave', () => { active = false; element.style.scrollBehavior = 'smooth'; });
        }

        let activeContextItem = null; 
        function updateMenuHighlight() {
            const items = Array.from(document.querySelectorAll('.context-menu-item'));
            const visibleItems = items.filter(item => item.style.display !== 'none');
            items.forEach(i => i.classList.remove('selected'));
            if (visibleItems.length > 0) {
                if (menuFocusIndex >= visibleItems.length) menuFocusIndex = visibleItems.length - 1;
                if (menuFocusIndex < 0) menuFocusIndex = 0;
                visibleItems[menuFocusIndex].classList.add('selected');
            }
        }

        function showContextMenu(e, id, type) {
            if(e) { e.preventDefault(); e.stopPropagation(); }
            activeContextItem = { id, type };
            const menu = document.getElementById('globalContextMenu');
            const unwatchBtn = document.getElementById('cmUnwatch');
            const blockBtn = document.querySelector('.context-menu-item[onclick="handleMenuAction(\'block\')"]');
            const isWatched = continueWatching.some(i => i.id == id);
            if (isWatched) { unwatchBtn.style.display = 'block'; blockBtn.style.display = 'block'; } else { unwatchBtn.style.display = 'none'; blockBtn.style.display = 'none'; }
            const clickX = e.pageX;
            const clickY = e.pageY;
            const menuWidth = 200;
            if (e.clientX + menuWidth > window.innerWidth) menu.style.left = `${clickX - menuWidth}px`; else menu.style.left = `${clickX}px`;
            menu.style.top = `${clickY + 10}px`;
            menu.classList.add('visible');
            isMenuOpen = true;
            lastFocusedCard = document.activeElement; 
            menuFocusIndex = 0; 
            updateMenuHighlight();
            setTimeout(() => { document.addEventListener('click', hideContextMenu, { once: true }); }, 10);
        }

        function hideContextMenu() {
            document.getElementById('globalContextMenu').classList.remove('visible');
            isMenuOpen = false;
            if (lastFocusedCard) lastFocusedCard.focus(); 
        }

        async function handleMenuAction(action) {
    if (!activeContextItem) return;
    const { id, type } = activeContextItem;
    
    if (action === 'unwatch') {
        // 1. Remove from Data (Local Storage)
        continueWatching = continueWatching.filter(i => i.id != id);
        if(activeProfile) localStorage.setItem(`ot_history_${activeProfile.id}`, JSON.stringify(continueWatching));
        
        // 2. Find the visual cards for this item
        const cards = Array.from(document.querySelectorAll('.carousel-item, .grid-item'));
        
        cards.forEach(card => {
            // We identify the card by checking its onclick handler for the ID
            if (card.innerHTML.includes(`showContextMenu(event, ${id}, '${type}')`)) {
                
                // --- THE ZOOM OUT ANIMATION ---
                // We force a transition to make it smooth
                card.style.transition = 'all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                
                // Shrink it down to nothing
                card.style.transform = 'scale(0)';
                card.style.opacity = '0';
                card.style.margin = '0'; // Collapse space
                card.style.width = '0';  // Collapse width
                
                // 3. Remove from DOM after animation finishes (300ms)
                setTimeout(() => {
                    const parentRow = card.closest('.carousel-container');
                    card.remove();
                    
                    // Cleanup: If the row is now empty, hide the entire row
                    if (parentRow) {
                        const remainingItems = parentRow.querySelectorAll('.carousel-item');
                        if (remainingItems.length === 0) {
                            const wholeRow = parentRow.closest('.row');
                            if(wholeRow) {
                                wholeRow.style.transition = 'opacity 0.3s';
                                wholeRow.style.opacity = '0';
                                setTimeout(() => wholeRow.remove(), 300);
                            }
                        }
                    }
                    
                    // If we just unwatched the hero background item, update the hero
                    if (currentId == id) updateHeroBackground();
                    
                }, 300); 
            }
        });
        
        hideContextMenu();
    } 
    else if (action === 'block') {
        // "Don't Recommend" - Add to block list, then trigger the unwatch animation
        blockedShows.push(id);
        localStorage.setItem('ot_blockedShows', JSON.stringify(blockedShows));
        handleMenuAction('unwatch'); 
    } 
    else if (action === 'info') {
        openInfoModal(id, type);
    }
}

        async function openInfoModal(id, type) {
            const modal = document.getElementById('infoModal');
            modal.classList.add('visible');
            document.querySelector('.main-content').classList.add('blur-background');
            document.getElementById('infoModalTitle').textContent = "> loading...";
            document.getElementById('infoModalDesc').textContent = "";
            document.getElementById('infoModalCast').innerHTML = "";
            try {
                const [itemRes, creditsRes] = await Promise.all([
                    fetch(`${TMDB_BASE}/${type}/${id}?api_key=${API_KEY}&language=en-US`),
                    fetch(`${TMDB_BASE}/${type}/${id}/credits?api_key=${API_KEY}&language=en-US`)
                ]);
                const item = await itemRes.json();
                const credits = await creditsRes.json();
                document.getElementById('infoModalTitle').textContent = (item.title || item.name).toLowerCase();
                document.getElementById('infoModalRating').textContent = item.vote_average ? `${item.vote_average.toFixed(1)}/10` : '--';
                document.getElementById('infoModalRuntime').textContent = type === 'movie' ? `${item.runtime || '--'} min` : `${item.number_of_seasons || '--'} seasons`;
                document.getElementById('infoModalDesc').textContent = (item.overview || 'no description available.').toLowerCase();
                let castHTML = '<h3 style="color:var(--text); margin-bottom:10px;">lead actors</h3>';
                credits.cast.slice(0, 4).forEach(c => {
                    castHTML += `<div style="display:inline-block; background:var(--input-bg); padding:5px 10px; margin:0 10px 10px 0; border:1px solid var(--border); font-size:14px;">${c.name.toLowerCase()}</div>`;
                });
                document.getElementById('infoModalCast').innerHTML = castHTML;
            } catch(e) { document.getElementById('infoModalTitle').textContent = "error loading info"; }
        }

        function closeInfoModal() {
            document.getElementById('infoModal').classList.remove('visible');
            document.querySelector('.main-content').classList.remove('blur-background');
        }

        function playFromInfoModal() {
            if(activeContextItem) {
                closeInfoModal();
                showDetail(activeContextItem.id, activeContextItem.type);
            }
        }

        function nextEpisode() {
            const btn = document.getElementById('nextEpBtn');
            btn.classList.remove('visible');
            const epSelect = document.getElementById('episodeSelect');
            if (currentEpisode < epSelect.options.length) {
                epSelect.value = currentEpisode + 1;
                epSelect.dispatchEvent(new Event('change'));
            } else {
                const seasonSelect = document.getElementById('seasonSelect');
                const nextSeason = currentSeason + 1;
                let seasonExists = false;
                for (let i = 0; i < seasonSelect.options.length; i++) { if (parseInt(seasonSelect.options[i].value) === nextSeason) seasonExists = true; }
                if (seasonExists) { seasonSelect.value = nextSeason; seasonSelect.dispatchEvent(new Event('change')); } 
                else { setStatus("no more episodes available."); }
            }
        }

        function togglePerfMode() {
            performanceMode = !performanceMode;
            localStorage.setItem('ot_perf', performanceMode);
            if(performanceMode) document.body.classList.add('performance-mode');
            else document.body.classList.remove('performance-mode');
        }


        // index.html - Final HUD Sync logic
setInterval(() => {
    if (document.body.classList.contains('video-ready')) {
        window.ipcRenderer.send('get-video-time');
    }
}, 1000);

let localState = {
        playing: false,
        currentTime: 0,
        duration: 1, 
        lastTick: Date.now()
    };

    // 2. THE ANIMATION LOOP (Runs 60x per second for butter-smooth UI)
    function playbackLoop() {
    const now = Date.now();
    const delta = (now - localState.lastTick) / 1000;
    localState.lastTick = now;

    if (localState.playing) {
        localState.currentTime += delta;
        // Cap at duration
        if (localState.currentTime > localState.duration) localState.currentTime = localState.duration;
    }

    updateHUDVisuals();
    
    // --- NEXT EPISODE TRIGGER (140s Remaining) ---
    if (localState.duration > 0 && currentType === 'tv') {
        const remaining = localState.duration - localState.currentTime;
        const btn = document.getElementById('nextEpBtn');
        
        // Show Button Window: Between 140s remaining and 0s
        if (remaining <= 140 && remaining > 0) {
            
            // Only calculate target ONCE when showing (Performance)
            if (!btn.classList.contains('visible')) {
                const nextTarget = findNextTarget();
                if (nextTarget) {
                    // Update Text
                    const rawTitle = nextTarget.name.split(':')[1] || nextTarget.name; // Clean "S1E2: Title" -> "Title"
                    document.getElementById('nextEpTitle').textContent = `> ${rawTitle.trim().toLowerCase()}`;
                    document.getElementById('nextEpTimer').textContent = "up next";
                    
                    // Show Button
                    btn.classList.add('visible');
                }
            }
        } 
        // Hide Button if user seeks backwards out of the zone
        else {
            if (btn.classList.contains('visible')) btn.classList.remove('visible');
        }
    }

    requestAnimationFrame(playbackLoop);
}

    requestAnimationFrame(playbackLoop);

    // 3. VISUAL UPDATE (Updates Bar & Text instantly)
    function updateHUDVisuals() {
        const percent = (localState.currentTime / localState.duration) * 100;
        const progressBar = document.getElementById('hudProgressBar');
        const timeLabel = document.getElementById('hudTime');
        
        // --- FIX: SELECT THE ICONS, NOT THE BUTTON ---
        const iconPlay = document.getElementById('iconPlay');
        const iconPause = document.getElementById('iconPause');

        if (progressBar) progressBar.style.width = `${Math.max(0, Math.min(100, percent))}%`;
        
        const format = (s) => {
            if (isNaN(s) || s < 0) s = 0;
            const mins = Math.floor(s / 60);
            const secs = Math.floor(s % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        };

        if (timeLabel) timeLabel.textContent = `${format(localState.currentTime)} / ${format(localState.duration)}`;
        
        // --- FIX: TOGGLE VISIBILITY (Don't destroy the SVG!) ---
        if (iconPlay && iconPause) {
            if (localState.playing) {
                iconPlay.style.display = 'none';
                iconPause.style.display = 'block';
            } else {
                iconPlay.style.display = 'block';
                iconPause.style.display = 'none';
            }
        }
        
        const durLabel = document.getElementById('duration');
        if (durLabel) durLabel.textContent = `${Math.floor(localState.duration / 60)} min`;
    }

    // 4. BACKEND SYNC (Corrects drift, doesn't drive animation)
    // 4. BACKEND SYNC (Corrects drift, doesn't drive animation)
window.ipcRenderer.on('video-time-data', (event, data) => {
    if (!data) return;

    // --- FIX: SAFETY CHECK ---
    // Only overwrite our local duration if the backend actually found a valid time (> 0)
    // This prevents the "00:00" bug when main.js can't read the video tag.
    if (data.total && data.total > 0) {
        localState.duration = data.total;
    }
    
    // Sync Play/Pause state
    localState.playing = !data.paused; 

    // SYNC TIME: Only snap if we drifted by more than 2 seconds
    const drift = Math.abs(data.curr - localState.currentTime);
    if (drift > 2 || !localState.playing) {
        localState.currentTime = data.curr;
    }
});

    // 5. INSTANT SEEK (Optimistic UI Update)
    function hudSeek(event) {
        const rect = event.currentTarget.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const percentage = Math.max(0, Math.min(1, x / rect.width));
        
        // A. Update Logic INSTANTLY
        localState.currentTime = localState.duration * percentage;
        
        // B. Force Visual Update INSTANTLY
        updateHUDVisuals();
        
        // C. Send Command to Backend
        window.ipcRenderer.send('video-command', { action: 'seek', percent: percentage });
    }

    // 6. INSTANT CONTROLS
function hudTogglePlay() {
        if (window.scrollY > 50) return; // Safety check
        window.ipcRenderer.send('video-command', 'togglePlay');

        // Optimistic UI Toggle (Instant Feedback)
        const iconPlay = document.getElementById('iconPlay');
        const iconPause = document.getElementById('iconPause');
        
        if (iconPlay && iconPause) {
            if (iconPlay.style.display !== 'none') {
                iconPlay.style.display = 'none';
                iconPause.style.display = 'block';
            } else {
                iconPlay.style.display = 'block';
                iconPause.style.display = 'none';
            }
        }
    }

    function hudForward() {
        localState.currentTime = Math.min(localState.duration, localState.currentTime + 10);
        updateHUDVisuals();
        window.ipcRenderer.send('video-command', 'forward');
    }

    function hudRewind() {
        localState.currentTime = Math.max(0, localState.currentTime - 10);
        updateHUDVisuals();
        window.ipcRenderer.send('video-command', 'rewind');
    }

    // =================================================================
    // SMART REMOTE NAVIGATION & HUD LOGIC
    // =================================================================

    // --- HUD VISIBILITY ---
    let hudHideTimer = null;
    const HUD_TIMEOUT = 3000;

    function wakeUpHUD() {
        // 1. Safety Checks
        if (!document.body.classList.contains('viewing-mode')) return;
        
        // 2. SCROLL LOCK CHECK (The Fix)
        // If we are currently scrolling away via keyboard, IGNORE this wake-up call.
        if (isKeyboardScrolling) return;

        // 3. Scroll Position Check
        // If we have scrolled down past the player, do not show HUD.
        if (window.scrollY > 50) return;

        const hud = document.getElementById('customHUD');
        const backBtn = document.getElementById('hudBackBtn');

        if (hud) hud.classList.add('visible');
        if (backBtn) backBtn.classList.add('visible');
        document.body.classList.add('user-active');

        // Reset Hide Timer
        clearTimeout(hudHideTimer);
        hudHideTimer = setTimeout(() => {
            if (!navState.isSeeking) forceHideHUD();
        }, HUD_TIMEOUT);
    }

    function forceHideHUD() {
        // Clear timer so it doesn't fire again randomly
        clearTimeout(hudHideTimer);
        
        const hud = document.getElementById('customHUD');
        const backBtn = document.getElementById('hudBackBtn');

        // Remove visibility classes -> Triggers CSS Opacity Fade
        if (hud) hud.classList.remove('visible');
        if (backBtn) backBtn.classList.remove('visible');
        document.body.classList.remove('user-active');
    }

    // --- INPUT LISTENERS (Wakes up HUD on any movement) ---
    document.addEventListener('mousemove', () => {
        if (window.scrollY < 50) wakeUpHUD();
    });
    
    

    document.addEventListener('scroll', () => {
        // Fade out HUD immediately on scroll down
        if (window.scrollY > 50) {
            document.getElementById('customHUD').classList.remove('visible');
        }
    });

    // =================================================================
    // REMOTE CONTROL NAVIGATION ENGINE
    // =================================================================
    
let navState = {
        activeRow: 2,   // Default to Row 2 (Controls)
        activeIndex: 1, // Default to Index 1 (Play/Pause)
        isSeeking: false,
        seekInterval: null
    };

    // MAP OF UI ELEMENTS
    // Row 0: Back
    // Row 1: Progress
    // Row 2: Rewind, Play, Forward
    // Row 3: Season, Episode
    // Row 4: Page Bottom (Info)

    function getFocusElement(row, index) {
    if (row === 0) return document.getElementById('hudBackBtn');
    if (row === 1) return document.getElementById('hudProgressContainer');
    if (row === 2) {
        // --- CHANGE: Added 'nextEpBtn' to the end of the list ---
        const btns = ['hudRewind', 'hudPlayPause', 'hudForward', 'nextEpBtn'];
        return document.getElementById(btns[index]);
    }
    if (row === 3) {
        if (index === 0) return document.getElementById('seasonSelect');
        if (index === 1) return document.getElementById('episodeSelect');
    }
    return null;
}

    function highlightElement(el) {
    document.querySelectorAll('.nav-focus').forEach(e => e.classList.remove('nav-focus'));
    if (el) {
        el.classList.add('nav-focus');
        el.focus({ preventScroll: true }); // THIS IS CRITICAL
    }
}

function setRemoteDefaultFocus() {
        navState.activeRow = 2;
        navState.activeIndex = 1; // Play Button
        const playBtn = document.getElementById('hudPlayPause');
        if(playBtn) highlightElement(playBtn);
        wakeUpHUD();
    }

    function handleRemoteNavigation(e) {
        if (!document.body.classList.contains('viewing-mode')) return;
        if (navState.isSeeking) { handleSeekInput(e); return; }

        const key = e.key;
        if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter', ' ', 'Spacebar'].includes(key)) return;

        e.preventDefault();

        // 1. UP MOVEMENT
        if (key === 'ArrowUp') {
            if (navState.activeRow === 4) { 
                navState.activeRow = 3; navState.activeIndex = 0;
                document.querySelector('.tv-controls-container').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            else if (navState.activeRow === 3) { 
                navState.activeRow = 2; navState.activeIndex = 1; 
                window.scrollTo({ top: 0, behavior: 'smooth' }); 
                // Unlock mouse when returning to top
                isKeyboardScrolling = false; 
                wakeUpHUD(); 
            }
            else if (navState.activeRow === 2) { 
                navState.activeRow = 0; navState.activeIndex = 0; 
            }
        }

        // 2. DOWN MOVEMENT (THE FIX)
        else if (key === 'ArrowDown') {
            // If on Back Button -> Go to Controls (HUD stays)
            if (kickstartLock) {
        console.log(" Navigation Blocked: Still initializing stream...");
        return; // <--- STOP HERE. Do not scroll.
    }

            if (navState.activeRow === 0) { 
                navState.activeRow = 2; navState.activeIndex = 1; 
            }
            // If on Controls -> Go to Content (HUD MUST HIDE)
            else if (navState.activeRow === 2 || navState.activeRow === 1) { 
                navState.activeRow = 3; 
                navState.activeIndex = 0; 
                
                // ENABLE SCROLL LOCK (Ignores mouse for 0.8s)
                isKeyboardScrolling = true;
                clearTimeout(scrollLockTimer);
                scrollLockTimer = setTimeout(() => { isKeyboardScrolling = false; }, 800);

                forceHideHUD(); 
                
                const controlsDiv = document.querySelector('.tv-controls-container');
                if (controlsDiv) {
                    const yOffset = -20; 
                    const y = controlsDiv.getBoundingClientRect().top + window.scrollY + yOffset;
                    window.scrollTo({ top: y, behavior: 'smooth' });
                }
            }
            // Standard Navigation
else if (navState.activeRow === 3) {

    return; 
}
        }

        // 3. LEFT/RIGHT
        else if (key === 'ArrowLeft') {
            if (navState.activeRow === 2) navState.activeIndex = Math.max(0, navState.activeIndex - 1);
            if (navState.activeRow === 3) navState.activeIndex = Math.max(0, navState.activeIndex - 1);
        }
        else if (key === 'ArrowRight') {
    if (navState.activeRow === 2) {
        const btn = document.getElementById('nextEpBtn');
        
        // --- LOGIC: Only allow moving to Index 3 if button is visible ---
        const isBtnVisible = btn && btn.classList.contains('visible');
        const maxIdx = isBtnVisible ? 3 : 2;
        
        navState.activeIndex = Math.min(maxIdx, navState.activeIndex + 1);
    }
    if (navState.activeRow === 3) navState.activeIndex = Math.min(1, navState.activeIndex + 1);
}

        // 4. ACTION
        else if (key === 'Enter' || key === ' ' || key === 'Spacebar') {
            const el = getFocusElement(navState.activeRow, navState.activeIndex);
            if (el) {
                if (el.id === 'hudPlayPause') { hudTogglePlay(); visualPress(el); } 
                else if (el.id === 'hudRewind') { hudRewind(); visualPress(el); }
                else if (el.id === 'hudForward') { hudForward(); visualPress(el); }
                else if (el.tagName === 'SELECT') { try { el.showPicker(); } catch (err) { el.click(); } }
                else { el.click(); }
            }
        }

        const target = getFocusElement(navState.activeRow, navState.activeIndex);
        if (target && navState.activeRow < 4) highlightElement(target);
    }

    // Helper for visual feedback
    function visualPress(el) {
        el.classList.add('active-press');
        setTimeout(() => el.classList.remove('active-press'), 150);
    }

    // =================================================================
    // SEEK ACCELERATION LOGIC
    // =================================================================

    function startSeekingMode() {
        navState.isSeeking = true;
        const progressBar = document.getElementById('hudProgressContainer');
        progressBar.style.borderColor = "#fff"; // Visual cue
        console.log("Seek Mode Active: Use Left/Right to scrub, Enter to commit.");
    }

    function handleSeekInput(e) {
        if (e.key === 'Enter') {
            // Commit Seek
            navState.isSeeking = false;
            clearInterval(navState.seekInterval);
            document.getElementById('hudProgressContainer').style.borderColor = ""; // Reset visual
            
            // Sync with backend
            const percent = localState.currentTime / localState.duration;
            window.ipcRenderer.send('video-command', { action: 'seek', percent: percent });
            return;
        }

        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            // We process holding logic via keydown repeat or manual interval?
            // Browsers handle key repeat natively on hold. We will use that.
            
            // Determine Direction
            const direction = e.key === 'ArrowRight' ? 1 : -1;
            
            // Determine Acceleration based on how long we've been holding?
            // Since keydown repeats, we can't easily timer "how long held" without keyup.
            // A simpler logic for remotes: Tap = 20s. Rapid Tap/Hold = Accel?
            
            // Let's implement the prompt's specific logic:
            // "if you hold it down... 2s=20s intervals, >2s=40s, >4s=60s"
            // To do this accurately on keydown, we need a timer that resets on keyup.
            
            if (!navState.seekInterval) {
                // First Press
                navState.seekStartTime = Date.now();
                
                // Start the loop
                navState.seekInterval = setInterval(() => {
                    const holdDuration = (Date.now() - navState.seekStartTime) / 1000;
                    let jumpAmount = 20;
                    if (holdDuration > 4) jumpAmount = 60;
                    else if (holdDuration > 2) jumpAmount = 40;

                    // Execute Jump locally
                    localState.currentTime = Math.max(0, Math.min(localState.duration, localState.currentTime + (jumpAmount * direction)));
                    updateHUDVisuals(); // Instant update
                    
                }, 333); // "Update 3 times per second" -> 1000/3  333ms
                
                // Execute immediate jump on first press
                localState.currentTime = Math.max(0, Math.min(localState.duration, localState.currentTime + (20 * direction)));
                updateHUDVisuals();
            }
        }
    }

    // =================================================================
// AUTO-UPDATER FRONTEND (The UI)
// =================================================================

// =================================================================
// AUTO-UPDATER LOGIC (Enhanced)
// =================================================================

function sendUpdateStatus(text, status, newVersion = null) {
    if (mainWindow) {
        mainWindow.webContents.send('update-message', { 
            text, 
            status, 
            currentVersion: app.getVersion(), 
            newVersion 
        });
    }
}

// 1. Event Listeners

const updateModal = document.getElementById('updateModal');
const updateTitle = document.getElementById('updateTitle');
const updateStatusText = document.getElementById('updateStatusText'); // Was 'updateDetails'
const updateActionBtn = document.getElementById('updateActionBtn');   // Was 'btnUpdateNow'
const updateSpinner = document.getElementById('updateSpinner');
const versionInfo = document.getElementById('versionInfo');

// 1. OPEN THE MODAL (Triggered by clicking "Check for Updates" in menu)
function checkForUpdates() {
    // Hide the main menu if it's open
    const menu = document.getElementById('logoMenu');
    if (menu) menu.classList.remove('visible');

    // Show Modal
    updateModal.classList.add('visible');
    updateModal.style.display = 'flex'; 
    
    // Reset UI State
    updateSpinner.style.display = 'block';
    updateActionBtn.style.display = 'none';
    versionInfo.style.display = 'none';
    
    updateTitle.innerText = "Checking...";
    updateStatusText.innerText = "Connecting to GitHub...";
    
    // Send signal to main.js
    window.ipcRenderer.send('check-for-updates');
}

// 2. START THE DOWNLOAD (Triggered by "UPDATE NOW" button)
function startDownload() {
    btnUpdateNow.innerText = "DOWNLOADING...";
    btnUpdateNow.disabled = true;
    updateSpinner.style.display = 'block';
    window.ipcRenderer.send('start-download');
}

// 3. CLOSE MODAL
function closeUpdateModal() {
    updateModal.classList.remove('visible');
    updateModal.style.display = 'none';
}

// 2. Commands from Frontend



let updateStatus = 'idle'; // idle, checking, downloading, ready

// =================================================================
// UPDATE CENTER LOGIC
// =================================================================
let updateState = 'idle'; // idle, checking, available, downloading, ready

function openUpdateModal() {
    // 1. Open Modal & Blur BG
    const modal = document.getElementById('updateModal');
    modal.classList.add('visible');
    document.querySelector('.main-content').classList.add('blur-background');
    
    // 2. Reset UI
    document.getElementById('updateSpinner').style.display = 'block';
    document.getElementById('updateStatusText').textContent = 'contacting servers...';
    document.getElementById('versionInfo').style.display = 'none';
    document.getElementById('updateActionBtn').style.display = 'none';
    document.getElementById('updateStatusText').className = ''; // Reset colors
    
    // 3. Trigger Check
    window.ipcRenderer.send('check-for-updates');
}

function closeUpdateModal() {
    document.getElementById('updateModal').classList.remove('visible');
    document.querySelector('.main-content').classList.remove('blur-background');
}

// CLICK HANDLER FOR MENU BUTTON
function handleUpdateClick() {
    document.getElementById('logoMenu').classList.remove('visible');
    
    updateModal.classList.add('visible');
    updateModal.style.display = 'flex'; // Force flex for centering
    
    // Reset UI State
    updateSpinner.style.display = 'block';
    updateActionBtn.style.display = 'none';
    versionInfo.style.display = 'none';
    
    updateTitle.innerText = "Checking...";
    updateStatusText.innerText = "Connecting to GitHub...";
    
    window.ipcRenderer.send('check-for-updates');
}

// CLICK HANDLER FOR MODAL BUTTON
function handleUpdateAction() {
    updateActionBtn.innerText = "DOWNLOADING...";
    updateActionBtn.disabled = true;
    updateSpinner.style.display = 'block';
    window.ipcRenderer.send('start-download');
}

// IPC LISTENER
window.ipcRenderer.on('update-message', (event, data) => {
    console.log("[UI] Update Status:", data);

    try {
        if (data.status === 'checking') {
            updateTitle.innerText = "Checking...";
        }
        else if (data.status === 'available') {
            updateSpinner.style.display = 'none';
            updateTitle.innerText = "new version available!";
            updateStatusText.innerText = "a new update is ready.";
            
            // Show Versions
            document.getElementById('currentVerDisplay').innerText = data.localVersion;
            document.getElementById('newVerDisplay').innerText = data.remoteVersion;
            versionInfo.style.display = 'block';
            
            // Show Button
            updateActionBtn.style.display = 'inline-block';
            updateActionBtn.innerText = "update now";
            updateActionBtn.disabled = false;
            updateActionBtn.onclick = handleUpdateAction; // Bind click
            updateActionBtn.focus();
        } 
        else if (data.status === 'uptodate') {
            updateSpinner.style.display = 'none';
            updateTitle.innerText = "you're up to date :)";
            updateStatusText.innerText = `Current Version: ${data.localVersion}`;
            updateActionBtn.style.display = 'none';
            
            setTimeout(closeUpdateModal, 2500);
        }
        else if (data.status === 'downloading') {
            updateSpinner.style.display = 'block';
            updateTitle.innerText = "downloading...";
            updateStatusText.innerText = "fetching files from github...";
            updateActionBtn.style.display = 'none';
        }
        else if (data.status === 'ready') {
            updateSpinner.style.display = 'none';
            updateTitle.innerText = "restarting...";
            updateStatusText.innerText = "applying changes...";
        }
        else if (data.status === 'error') {
            updateSpinner.style.display = 'none';
            updateTitle.innerText = "Error";
            updateStatusText.innerText = data.text;
        }
    } catch (err) {
        console.error("UI Update Error:", err);
    }
});

    // Reset seek timers on key release
    document.addEventListener('keyup', (e) => {
        if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && navState.isSeeking) {
            clearInterval(navState.seekInterval);
            navState.seekInterval = null;
        }
    });

    // Exit Cinematic function for Back Button
    function exitCinematicMode() {
        document.body.classList.remove('viewing-mode');
        showHome(); // Or whatever logic you use to go back
    }

    // Poll for time as a backup (keeps the sync alive)
    setInterval(() => {
        if (document.body.classList.contains('video-ready')) {
            window.ipcRenderer.send('get-video-time');
        }
    }, 1000);
    </script>
    <button id="hudBackBtn" class="floating-back-btn" onclick="exitCinematicMode()"> back</button>

<div id="customHUD">
    <div id="hudProgressContainer" class="hud-progress-container" onclick="hudSeek(event)">
        <div id="hudProgressBar" class="hud-progress-bar"></div>
        <div id="hudProgressHandle" class="progress-handle"></div> 
    </div>

    <div class="hud-controls">
        <button id="hudRewind" class="hud-btn" onclick="hudRewind()">
            <svg width="60" height="60" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M2 7H5V17H2V7Z" fill="currentColor" />
                <path d="M6 12L13.0023 7.00003V17L6 12Z" fill="currentColor" />
                <path d="M21.0023 7.00003L14 12L21.0023 17V7.00003Z" fill="currentColor" />
            </svg>
        </button>

        <button id="hudPlayPause" class="hud-btn" onclick="hudTogglePlay()">
            <svg id="iconPlay" width="60" height="60" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 3L22 12L3 21V3Z" fill="currentColor" />
            </svg>
            
            <svg id="iconPause" style="display:none;" width="60" height="60" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="4" y="3" width="6" height="18" rx="1" fill="currentColor" />
                <rect x="14" y="3" width="6" height="18" rx="1" fill="currentColor" />
            </svg>
        </button>

        <button id="hudForward" class="hud-btn" onclick="hudForward()">
            <svg width="60" height="60" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M21.0023 17H18.0023V7H21.0023V17Z" fill="currentColor" />
                <path d="M17.0023 12L10 17V7L17.0023 12Z" fill="currentColor" />
                <path d="M2 17L9.00232 12L2 7V17Z" fill="currentColor" />
            </svg>
        </button>

        <div id="hudTime">00:00 / 00:00</div>
    </div>
</div>
</div>
</body>
</html>